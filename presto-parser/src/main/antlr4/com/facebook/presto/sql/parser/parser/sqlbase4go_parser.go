// Code generated from SqlBase4Go.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // SqlBase4Go

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 236, 1725,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 3, 2,
	3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 173, 10, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 178, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 184,
	10, 5, 3, 5, 3, 5, 5, 5, 188, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 202, 10, 5, 3, 5, 3, 5, 5, 5,
	206, 10, 5, 3, 5, 3, 5, 5, 5, 210, 10, 5, 3, 5, 3, 5, 5, 5, 214, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 222, 10, 5, 3, 5, 3, 5, 5, 5,
	226, 10, 5, 3, 5, 5, 5, 229, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	236, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 243, 10, 5, 12, 5, 14,
	5, 246, 11, 5, 3, 5, 3, 5, 3, 5, 5, 5, 251, 10, 5, 3, 5, 3, 5, 5, 5, 255,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 261, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 268, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5,
	277, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 313, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 318, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 329, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 335, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 343,
	10, 5, 12, 5, 14, 5, 346, 11, 5, 5, 5, 348, 10, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 5, 5, 355, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5,
	5, 364, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 372, 10, 5, 3,
	5, 3, 5, 5, 5, 376, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 384,
	10, 5, 12, 5, 14, 5, 387, 11, 5, 5, 5, 389, 10, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 399, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 410, 10, 5, 12, 5, 14, 5, 413, 11, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 418, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 423, 10, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 429, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	7, 5, 436, 10, 5, 12, 5, 14, 5, 439, 11, 5, 3, 5, 3, 5, 3, 5, 5, 5, 444,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 451, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 7, 5, 457, 10, 5, 12, 5, 14, 5, 460, 11, 5, 3, 5, 3, 5, 5, 5, 464,
	10, 5, 3, 5, 3, 5, 5, 5, 468, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 476, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 482, 10, 5, 3, 5, 3, 5,
	3, 5, 7, 5, 487, 10, 5, 12, 5, 14, 5, 490, 11, 5, 3, 5, 3, 5, 5, 5, 494,
	10, 5, 3, 5, 3, 5, 5, 5, 498, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 508, 10, 5, 3, 5, 5, 5, 511, 10, 5, 3, 5, 3, 5, 5, 5,
	515, 10, 5, 3, 5, 5, 5, 518, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 524,
	10, 5, 12, 5, 14, 5, 527, 11, 5, 3, 5, 3, 5, 5, 5, 531, 10, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 547, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 553, 10, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 5, 5, 559, 10, 5, 5, 5, 561, 10, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 5, 5, 567, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 573, 10, 5, 5, 5, 575,
	10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 581, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 600, 10, 5, 3, 5, 3, 5, 3, 5, 5, 5, 605, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 612, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 624, 10, 5, 5, 5, 626, 10, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 7, 5, 644, 10, 5, 12, 5, 14, 5, 647, 11, 5, 5, 5, 649, 10,
	5, 3, 5, 3, 5, 5, 5, 653, 10, 5, 3, 5, 3, 5, 5, 5, 657, 10, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 7, 5, 673, 10, 5, 12, 5, 14, 5, 676, 11, 5, 5, 5, 678, 10, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 686, 10, 5, 3, 6, 5, 6, 689, 10, 6,
	3, 6, 3, 6, 3, 7, 3, 7, 5, 7, 695, 10, 7, 3, 7, 3, 7, 3, 7, 7, 7, 700,
	10, 7, 12, 7, 14, 7, 703, 11, 7, 3, 8, 3, 8, 5, 8, 707, 10, 8, 3, 9, 3,
	9, 3, 9, 3, 9, 5, 9, 713, 10, 9, 3, 9, 3, 9, 5, 9, 717, 10, 9, 3, 9, 3,
	9, 5, 9, 721, 10, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 727, 10, 10, 3,
	11, 3, 11, 3, 11, 3, 11, 7, 11, 733, 10, 11, 12, 11, 14, 11, 736, 11, 11,
	3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 14, 7,
	14, 748, 10, 14, 12, 14, 14, 14, 751, 11, 14, 3, 15, 3, 15, 3, 15, 3, 15,
	5, 15, 757, 10, 15, 3, 16, 7, 16, 760, 10, 16, 12, 16, 14, 16, 763, 11,
	16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 21,
	3, 21, 3, 21, 5, 21, 777, 10, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 788, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 7, 23, 796, 10, 23, 12, 23, 14, 23, 799, 11, 23, 5, 23, 801,
	10, 23, 3, 23, 3, 23, 5, 23, 805, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 5, 24, 813, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 819,
	10, 24, 3, 24, 7, 24, 822, 10, 24, 12, 24, 14, 24, 825, 11, 24, 3, 25,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 834, 10, 25, 12, 25, 14,
	25, 837, 11, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 843, 10, 25, 3, 26,
	3, 26, 5, 26, 847, 10, 26, 3, 26, 3, 26, 5, 26, 851, 10, 26, 3, 27, 3,
	27, 5, 27, 855, 10, 27, 3, 27, 3, 27, 3, 27, 7, 27, 860, 10, 27, 12, 27,
	14, 27, 863, 11, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 869, 10, 27, 12,
	27, 14, 27, 872, 11, 27, 5, 27, 874, 10, 27, 3, 27, 3, 27, 5, 27, 878,
	10, 27, 3, 27, 3, 27, 3, 27, 5, 27, 883, 10, 27, 3, 27, 3, 27, 5, 27, 887,
	10, 27, 3, 28, 5, 28, 890, 10, 28, 3, 28, 3, 28, 3, 28, 7, 28, 895, 10,
	28, 12, 28, 14, 28, 898, 11, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 7, 29, 906, 10, 29, 12, 29, 14, 29, 909, 11, 29, 5, 29, 911, 10, 29,
	3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 919, 10, 29, 12, 29, 14,
	29, 922, 11, 29, 5, 29, 924, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 3, 29, 7, 29, 933, 10, 29, 12, 29, 14, 29, 936, 11, 29, 3, 29, 3,
	29, 5, 29, 940, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 946, 10, 30,
	12, 30, 14, 30, 949, 11, 30, 5, 30, 951, 10, 30, 3, 30, 3, 30, 5, 30, 955,
	10, 30, 3, 31, 3, 31, 5, 31, 959, 10, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 32, 3, 32, 3, 33, 3, 33, 5, 33, 970, 10, 33, 3, 33, 5, 33, 973,
	10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 980, 10, 33, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 999, 10, 34, 7, 34, 1001, 10,
	34, 12, 34, 14, 34, 1004, 11, 34, 3, 35, 5, 35, 1007, 10, 35, 3, 35, 3,
	35, 5, 35, 1011, 10, 35, 3, 35, 3, 35, 5, 35, 1015, 10, 35, 3, 35, 3, 35,
	5, 35, 1019, 10, 35, 5, 35, 1021, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3,
	36, 3, 36, 3, 36, 7, 36, 1030, 10, 36, 12, 36, 14, 36, 1033, 11, 36, 3,
	36, 3, 36, 5, 36, 1037, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 5, 37, 1046, 10, 37, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 1052, 10,
	39, 3, 39, 3, 39, 5, 39, 1056, 10, 39, 5, 39, 1058, 10, 39, 3, 40, 3, 40,
	3, 40, 3, 40, 7, 40, 1064, 10, 40, 12, 40, 14, 40, 1067, 11, 40, 3, 40,
	3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 7, 41, 1081, 10, 41, 12, 41, 14, 41, 1084, 11, 41, 3, 41, 3, 41, 3,
	41, 5, 41, 1089, 10, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	3, 41, 3, 41, 5, 41, 1100, 10, 41, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 5,
	43, 1107, 10, 43, 3, 43, 3, 43, 5, 43, 1111, 10, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 7, 43, 1119, 10, 43, 12, 43, 14, 43, 1122, 11, 43,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5,
	44, 1134, 10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1142,
	10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 1149, 10, 44, 12, 44,
	14, 44, 1152, 11, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1157, 10, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1165, 10, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 5, 44, 1171, 10, 44, 3, 44, 3, 44, 5, 44, 1175, 10, 44, 3, 44,
	3, 44, 3, 44, 5, 44, 1180, 10, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1185, 10,
	44, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 1191, 10, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 1205,
	10, 45, 12, 45, 14, 45, 1208, 11, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 6, 46, 1234,
	10, 46, 13, 46, 14, 46, 1235, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 7, 46, 1245, 10, 46, 12, 46, 14, 46, 1248, 11, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1257, 10, 46, 3, 46, 5, 46, 1260,
	10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1265, 10, 46, 3, 46, 3, 46, 3, 46,
	7, 46, 1270, 10, 46, 12, 46, 14, 46, 1273, 11, 46, 5, 46, 1275, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 1282, 10, 46, 12, 46, 14, 46,
	1285, 11, 46, 5, 46, 1287, 10, 46, 3, 46, 3, 46, 5, 46, 1291, 10, 46, 3,
	46, 5, 46, 1294, 10, 46, 3, 46, 5, 46, 1297, 10, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 1307, 10, 46, 12, 46, 14, 46,
	1310, 11, 46, 5, 46, 1312, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 6, 46,
	1329, 10, 46, 13, 46, 14, 46, 1330, 3, 46, 3, 46, 5, 46, 1335, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 6, 46, 1341, 10, 46, 13, 46, 14, 46, 1342,
	3, 46, 3, 46, 5, 46, 1347, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 1370, 10, 46, 12, 46, 14, 46,
	1373, 11, 46, 5, 46, 1375, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 5, 46, 1384, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1390,
	10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 1396, 10, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 5, 46, 1402, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 5, 46, 1412, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 5, 46, 1421, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 7, 46, 1441, 10, 46, 12, 46, 14, 46, 1444, 11, 46, 5, 46,
	1446, 10, 46, 3, 46, 5, 46, 1449, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 7, 46, 1459, 10, 46, 12, 46, 14, 46, 1462, 11,
	46, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1468, 10, 47, 3, 48, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 5, 48, 1476, 10, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3,
	51, 3, 51, 3, 52, 3, 52, 5, 52, 1486, 10, 52, 3, 52, 3, 52, 3, 52, 3, 52,
	5, 52, 1492, 10, 52, 3, 53, 3, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3,
	55, 7, 55, 1502, 10, 55, 12, 55, 14, 55, 1505, 11, 55, 5, 55, 1507, 10,
	55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 7, 56, 1532, 10, 56, 12, 56, 14, 56, 1535, 11, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 7, 56, 1544, 10, 56, 12,
	56, 14, 56, 1547, 11, 56, 3, 56, 3, 56, 5, 56, 1551, 10, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 5, 56, 1558, 10, 56, 3, 56, 3, 56, 7, 56, 1562,
	10, 56, 12, 56, 14, 56, 1565, 11, 56, 3, 57, 3, 57, 5, 57, 1569, 10, 57,
	3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1575, 10, 58, 3, 59, 3, 59, 3, 59, 3,
	59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 7, 61, 1595, 10, 61, 12, 61, 14, 61, 1598,
	11, 61, 5, 61, 1600, 10, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 7, 61,
	1607, 10, 61, 12, 61, 14, 61, 1610, 11, 61, 5, 61, 1612, 10, 61, 3, 61,
	5, 61, 1615, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3,
	62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62,
	5, 62, 1635, 10, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 3, 63, 5, 63, 1646, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 1652,
	10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 1659, 10, 65, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1668, 10, 66, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 5, 67, 1675, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68,
	5, 68, 1681, 10, 68, 3, 69, 3, 69, 3, 69, 7, 69, 1686, 10, 69, 12, 69,
	14, 69, 1689, 11, 69, 3, 70, 3, 70, 3, 70, 5, 70, 1694, 10, 70, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 5, 71, 1701, 10, 71, 3, 72, 3, 72, 3, 72, 7,
	72, 1706, 10, 72, 12, 72, 14, 72, 1709, 11, 72, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 5, 73, 1716, 10, 73, 3, 74, 3, 74, 3, 74, 5, 74, 1721, 10, 74,
	3, 75, 3, 75, 3, 75, 2, 8, 46, 66, 84, 88, 90, 110, 76, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
	84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
	116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
	146, 148, 2, 23, 4, 2, 29, 29, 150, 150, 4, 2, 74, 74, 88, 88, 4, 2, 63,
	63, 89, 89, 4, 2, 15, 15, 222, 222, 4, 2, 62, 62, 191, 191, 4, 2, 22, 22,
	53, 53, 4, 2, 70, 70, 102, 102, 4, 2, 15, 15, 56, 56, 4, 2, 24, 24, 175,
	175, 3, 2, 213, 214, 3, 2, 215, 217, 3, 2, 207, 212, 5, 2, 15, 15, 19,
	19, 170, 170, 4, 2, 68, 68, 185, 185, 7, 2, 50, 50, 85, 85, 112, 113, 163,
	163, 205, 205, 3, 2, 115, 118, 4, 2, 71, 71, 138, 138, 5, 2, 81, 81, 99,
	99, 179, 179, 6, 2, 57, 57, 96, 96, 110, 110, 196, 196, 4, 2, 127, 127,
	204, 204, 47, 2, 13, 15, 17, 17, 19, 20, 22, 24, 27, 29, 32, 37, 42, 42,
	44, 44, 48, 50, 53, 53, 55, 55, 57, 57, 63, 63, 66, 66, 69, 71, 73, 73,
	76, 81, 85, 87, 89, 89, 91, 91, 94, 94, 96, 96, 98, 99, 101, 103, 105,
	105, 107, 107, 110, 113, 115, 120, 124, 125, 127, 128, 131, 131, 133, 138,
	140, 143, 145, 153, 155, 157, 159, 163, 165, 175, 177, 179, 181, 184, 186,
	187, 189, 190, 193, 194, 196, 196, 198, 199, 203, 206, 2, 1991, 2, 150,
	3, 2, 2, 2, 4, 153, 3, 2, 2, 2, 6, 156, 3, 2, 2, 2, 8, 685, 3, 2, 2, 2,
	10, 688, 3, 2, 2, 2, 12, 692, 3, 2, 2, 2, 14, 706, 3, 2, 2, 2, 16, 708,
	3, 2, 2, 2, 18, 722, 3, 2, 2, 2, 20, 728, 3, 2, 2, 2, 22, 739, 3, 2, 2,
	2, 24, 743, 3, 2, 2, 2, 26, 749, 3, 2, 2, 2, 28, 756, 3, 2, 2, 2, 30, 761,
	3, 2, 2, 2, 32, 764, 3, 2, 2, 2, 34, 766, 3, 2, 2, 2, 36, 768, 3, 2, 2,
	2, 38, 771, 3, 2, 2, 2, 40, 776, 3, 2, 2, 2, 42, 787, 3, 2, 2, 2, 44, 789,
	3, 2, 2, 2, 46, 806, 3, 2, 2, 2, 48, 842, 3, 2, 2, 2, 50, 844, 3, 2, 2,
	2, 52, 852, 3, 2, 2, 2, 54, 889, 3, 2, 2, 2, 56, 939, 3, 2, 2, 2, 58, 954,
	3, 2, 2, 2, 60, 956, 3, 2, 2, 2, 62, 965, 3, 2, 2, 2, 64, 979, 3, 2, 2,
	2, 66, 981, 3, 2, 2, 2, 68, 1020, 3, 2, 2, 2, 70, 1036, 3, 2, 2, 2, 72,
	1038, 3, 2, 2, 2, 74, 1047, 3, 2, 2, 2, 76, 1049, 3, 2, 2, 2, 78, 1059,
	3, 2, 2, 2, 80, 1099, 3, 2, 2, 2, 82, 1101, 3, 2, 2, 2, 84, 1110, 3, 2,
	2, 2, 86, 1184, 3, 2, 2, 2, 88, 1190, 3, 2, 2, 2, 90, 1448, 3, 2, 2, 2,
	92, 1467, 3, 2, 2, 2, 94, 1475, 3, 2, 2, 2, 96, 1477, 3, 2, 2, 2, 98, 1479,
	3, 2, 2, 2, 100, 1481, 3, 2, 2, 2, 102, 1483, 3, 2, 2, 2, 104, 1493, 3,
	2, 2, 2, 106, 1495, 3, 2, 2, 2, 108, 1497, 3, 2, 2, 2, 110, 1557, 3, 2,
	2, 2, 112, 1568, 3, 2, 2, 2, 114, 1574, 3, 2, 2, 2, 116, 1576, 3, 2, 2,
	2, 118, 1581, 3, 2, 2, 2, 120, 1587, 3, 2, 2, 2, 122, 1634, 3, 2, 2, 2,
	124, 1645, 3, 2, 2, 2, 126, 1651, 3, 2, 2, 2, 128, 1658, 3, 2, 2, 2, 130,
	1667, 3, 2, 2, 2, 132, 1674, 3, 2, 2, 2, 134, 1680, 3, 2, 2, 2, 136, 1682,
	3, 2, 2, 2, 138, 1693, 3, 2, 2, 2, 140, 1700, 3, 2, 2, 2, 142, 1702, 3,
	2, 2, 2, 144, 1715, 3, 2, 2, 2, 146, 1720, 3, 2, 2, 2, 148, 1722, 3, 2,
	2, 2, 150, 151, 5, 8, 5, 2, 151, 152, 7, 2, 2, 3, 152, 3, 3, 2, 2, 2, 153,
	154, 5, 82, 42, 2, 154, 155, 7, 2, 2, 3, 155, 5, 3, 2, 2, 2, 156, 157,
	5, 34, 18, 2, 157, 158, 7, 2, 2, 3, 158, 7, 3, 2, 2, 2, 159, 686, 5, 10,
	6, 2, 160, 161, 7, 193, 2, 2, 161, 686, 5, 144, 73, 2, 162, 163, 7, 193,
	2, 2, 163, 164, 5, 144, 73, 2, 164, 165, 7, 3, 2, 2, 165, 166, 5, 144,
	73, 2, 166, 686, 3, 2, 2, 2, 167, 168, 7, 39, 2, 2, 168, 172, 7, 161, 2,
	2, 169, 170, 7, 86, 2, 2, 170, 171, 7, 122, 2, 2, 171, 173, 7, 65, 2, 2,
	172, 169, 3, 2, 2, 2, 172, 173, 3, 2, 2, 2, 173, 174, 3, 2, 2, 2, 174,
	177, 5, 136, 69, 2, 175, 176, 7, 202, 2, 2, 176, 178, 5, 20, 11, 2, 177,
	175, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 178, 686, 3, 2, 2, 2, 179, 180,
	7, 58, 2, 2, 180, 183, 7, 161, 2, 2, 181, 182, 7, 86, 2, 2, 182, 184, 7,
	65, 2, 2, 183, 181, 3, 2, 2, 2, 183, 184, 3, 2, 2, 2, 184, 185, 3, 2, 2,
	2, 185, 187, 5, 136, 69, 2, 186, 188, 9, 2, 2, 2, 187, 186, 3, 2, 2, 2,
	187, 188, 3, 2, 2, 2, 188, 686, 3, 2, 2, 2, 189, 190, 7, 16, 2, 2, 190,
	191, 7, 161, 2, 2, 191, 192, 5, 136, 69, 2, 192, 193, 7, 145, 2, 2, 193,
	194, 7, 183, 2, 2, 194, 195, 5, 144, 73, 2, 195, 686, 3, 2, 2, 2, 196,
	197, 7, 39, 2, 2, 197, 201, 7, 176, 2, 2, 198, 199, 7, 86, 2, 2, 199, 200,
	7, 122, 2, 2, 200, 202, 7, 65, 2, 2, 201, 198, 3, 2, 2, 2, 201, 202, 3,
	2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 205, 5, 136, 69, 2, 204, 206, 5, 78,
	40, 2, 205, 204, 3, 2, 2, 2, 205, 206, 3, 2, 2, 2, 206, 209, 3, 2, 2, 2,
	207, 208, 7, 35, 2, 2, 208, 210, 7, 12, 2, 2, 209, 207, 3, 2, 2, 2, 209,
	210, 3, 2, 2, 2, 210, 213, 3, 2, 2, 2, 211, 212, 7, 202, 2, 2, 212, 214,
	5, 20, 11, 2, 213, 211, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 215, 3,
	2, 2, 2, 215, 221, 7, 21, 2, 2, 216, 222, 5, 10, 6, 2, 217, 218, 7, 4,
	2, 2, 218, 219, 5, 10, 6, 2, 219, 220, 7, 5, 2, 2, 220, 222, 3, 2, 2, 2,
	221, 216, 3, 2, 2, 2, 221, 217, 3, 2, 2, 2, 222, 228, 3, 2, 2, 2, 223,
	225, 7, 202, 2, 2, 224, 226, 7, 119, 2, 2, 225, 224, 3, 2, 2, 2, 225, 226,
	3, 2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 229, 7, 48, 2, 2, 228, 223, 3, 2,
	2, 2, 228, 229, 3, 2, 2, 2, 229, 686, 3, 2, 2, 2, 230, 231, 7, 39, 2, 2,
	231, 235, 7, 176, 2, 2, 232, 233, 7, 86, 2, 2, 233, 234, 7, 122, 2, 2,
	234, 236, 7, 65, 2, 2, 235, 232, 3, 2, 2, 2, 235, 236, 3, 2, 2, 2, 236,
	237, 3, 2, 2, 2, 237, 238, 5, 136, 69, 2, 238, 239, 7, 4, 2, 2, 239, 244,
	5, 14, 8, 2, 240, 241, 7, 6, 2, 2, 241, 243, 5, 14, 8, 2, 242, 240, 3,
	2, 2, 2, 243, 246, 3, 2, 2, 2, 244, 242, 3, 2, 2, 2, 244, 245, 3, 2, 2,
	2, 245, 247, 3, 2, 2, 2, 246, 244, 3, 2, 2, 2, 247, 250, 7, 5, 2, 2, 248,
	249, 7, 35, 2, 2, 249, 251, 7, 12, 2, 2, 250, 248, 3, 2, 2, 2, 250, 251,
	3, 2, 2, 2, 251, 254, 3, 2, 2, 2, 252, 253, 7, 202, 2, 2, 253, 255, 5,
	20, 11, 2, 254, 252, 3, 2, 2, 2, 254, 255, 3, 2, 2, 2, 255, 686, 3, 2,
	2, 2, 256, 257, 7, 58, 2, 2, 257, 260, 7, 176, 2, 2, 258, 259, 7, 86, 2,
	2, 259, 261, 7, 65, 2, 2, 260, 258, 3, 2, 2, 2, 260, 261, 3, 2, 2, 2, 261,
	262, 3, 2, 2, 2, 262, 686, 5, 136, 69, 2, 263, 264, 7, 92, 2, 2, 264, 265,
	7, 95, 2, 2, 265, 267, 5, 136, 69, 2, 266, 268, 5, 78, 40, 2, 267, 266,
	3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 270, 5, 10,
	6, 2, 270, 686, 3, 2, 2, 2, 271, 272, 7, 52, 2, 2, 272, 273, 7, 74, 2,
	2, 273, 276, 5, 136, 69, 2, 274, 275, 7, 201, 2, 2, 275, 277, 5, 84, 43,
	2, 276, 274, 3, 2, 2, 2, 276, 277, 3, 2, 2, 2, 277, 686, 3, 2, 2, 2, 278,
	279, 7, 16, 2, 2, 279, 280, 7, 176, 2, 2, 280, 281, 5, 136, 69, 2, 281,
	282, 7, 145, 2, 2, 282, 283, 7, 183, 2, 2, 283, 284, 5, 136, 69, 2, 284,
	686, 3, 2, 2, 2, 285, 286, 7, 16, 2, 2, 286, 287, 7, 176, 2, 2, 287, 288,
	5, 136, 69, 2, 288, 289, 7, 145, 2, 2, 289, 290, 7, 33, 2, 2, 290, 291,
	5, 144, 73, 2, 291, 292, 7, 183, 2, 2, 292, 293, 5, 144, 73, 2, 293, 686,
	3, 2, 2, 2, 294, 295, 7, 16, 2, 2, 295, 296, 7, 176, 2, 2, 296, 297, 5,
	136, 69, 2, 297, 298, 7, 58, 2, 2, 298, 299, 7, 33, 2, 2, 299, 300, 5,
	136, 69, 2, 300, 686, 3, 2, 2, 2, 301, 302, 7, 16, 2, 2, 302, 303, 7, 176,
	2, 2, 303, 304, 5, 136, 69, 2, 304, 305, 7, 13, 2, 2, 305, 306, 7, 33,
	2, 2, 306, 307, 5, 16, 9, 2, 307, 686, 3, 2, 2, 2, 308, 309, 7, 17, 2,
	2, 309, 312, 5, 136, 69, 2, 310, 311, 7, 202, 2, 2, 311, 313, 5, 20, 11,
	2, 312, 310, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 686, 3, 2, 2, 2, 314,
	317, 7, 39, 2, 2, 315, 316, 7, 129, 2, 2, 316, 318, 7, 147, 2, 2, 317,
	315, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 320,
	7, 199, 2, 2, 320, 321, 5, 136, 69, 2, 321, 322, 7, 21, 2, 2, 322, 323,
	5, 10, 6, 2, 323, 686, 3, 2, 2, 2, 324, 325, 7, 58, 2, 2, 325, 328, 7,
	199, 2, 2, 326, 327, 7, 86, 2, 2, 327, 329, 7, 65, 2, 2, 328, 326, 3, 2,
	2, 2, 328, 329, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 686, 5, 136, 69,
	2, 331, 334, 7, 39, 2, 2, 332, 333, 7, 129, 2, 2, 333, 335, 7, 147, 2,
	2, 334, 332, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336,
	337, 7, 76, 2, 2, 337, 338, 5, 136, 69, 2, 338, 347, 7, 4, 2, 2, 339, 344,
	5, 24, 13, 2, 340, 341, 7, 6, 2, 2, 341, 343, 5, 24, 13, 2, 342, 340, 3,
	2, 2, 2, 343, 346, 3, 2, 2, 2, 344, 342, 3, 2, 2, 2, 344, 345, 3, 2, 2,
	2, 345, 348, 3, 2, 2, 2, 346, 344, 3, 2, 2, 2, 347, 339, 3, 2, 2, 2, 347,
	348, 3, 2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 350, 7, 5, 2, 2, 350, 351,
	7, 152, 2, 2, 351, 354, 5, 110, 56, 2, 352, 353, 7, 35, 2, 2, 353, 355,
	7, 12, 2, 2, 354, 352, 3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355, 356, 3, 2,
	2, 2, 356, 357, 5, 26, 14, 2, 357, 358, 5, 34, 18, 2, 358, 686, 3, 2, 2,
	2, 359, 360, 7, 16, 2, 2, 360, 361, 7, 76, 2, 2, 361, 363, 5, 136, 69,
	2, 362, 364, 5, 108, 55, 2, 363, 362, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2,
	364, 365, 3, 2, 2, 2, 365, 366, 5, 30, 16, 2, 366, 686, 3, 2, 2, 2, 367,
	368, 7, 58, 2, 2, 368, 371, 7, 76, 2, 2, 369, 370, 7, 86, 2, 2, 370, 372,
	7, 65, 2, 2, 371, 369, 3, 2, 2, 2, 371, 372, 3, 2, 2, 2, 372, 373, 3, 2,
	2, 2, 373, 375, 5, 136, 69, 2, 374, 376, 5, 108, 55, 2, 375, 374, 3, 2,
	2, 2, 375, 376, 3, 2, 2, 2, 376, 686, 3, 2, 2, 2, 377, 378, 7, 27, 2, 2,
	378, 379, 5, 136, 69, 2, 379, 388, 7, 4, 2, 2, 380, 385, 5, 132, 67, 2,
	381, 382, 7, 6, 2, 2, 382, 384, 5, 132, 67, 2, 383, 381, 3, 2, 2, 2, 384,
	387, 3, 2, 2, 2, 385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 389,
	3, 2, 2, 2, 387, 385, 3, 2, 2, 2, 388, 380, 3, 2, 2, 2, 388, 389, 3, 2,
	2, 2, 389, 390, 3, 2, 2, 2, 390, 391, 7, 5, 2, 2, 391, 686, 3, 2, 2, 2,
	392, 393, 7, 39, 2, 2, 393, 394, 7, 155, 2, 2, 394, 398, 5, 144, 73, 2,
	395, 396, 7, 202, 2, 2, 396, 397, 7, 14, 2, 2, 397, 399, 5, 138, 70, 2,
	398, 395, 3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399, 686, 3, 2, 2, 2, 400,
	401, 7, 58, 2, 2, 401, 402, 7, 155, 2, 2, 402, 686, 5, 144, 73, 2, 403,
	404, 7, 78, 2, 2, 404, 405, 5, 142, 72, 2, 405, 406, 7, 183, 2, 2, 406,
	411, 5, 140, 71, 2, 407, 408, 7, 6, 2, 2, 408, 410, 5, 140, 71, 2, 409,
	407, 3, 2, 2, 2, 410, 413, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 411, 412,
	3, 2, 2, 2, 412, 417, 3, 2, 2, 2, 413, 411, 3, 2, 2, 2, 414, 415, 7, 202,
	2, 2, 415, 416, 7, 14, 2, 2, 416, 418, 7, 128, 2, 2, 417, 414, 3, 2, 2,
	2, 417, 418, 3, 2, 2, 2, 418, 422, 3, 2, 2, 2, 419, 420, 7, 79, 2, 2, 420,
	421, 7, 26, 2, 2, 421, 423, 5, 138, 70, 2, 422, 419, 3, 2, 2, 2, 422, 423,
	3, 2, 2, 2, 423, 686, 3, 2, 2, 2, 424, 428, 7, 153, 2, 2, 425, 426, 7,
	14, 2, 2, 426, 427, 7, 128, 2, 2, 427, 429, 7, 72, 2, 2, 428, 425, 3, 2,
	2, 2, 428, 429, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 431, 5, 142, 72,
	2, 431, 432, 7, 74, 2, 2, 432, 437, 5, 140, 71, 2, 433, 434, 7, 6, 2, 2,
	434, 436, 5, 140, 71, 2, 435, 433, 3, 2, 2, 2, 436, 439, 3, 2, 2, 2, 437,
	435, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 443, 3, 2, 2, 2, 439, 437,
	3, 2, 2, 2, 440, 441, 7, 79, 2, 2, 441, 442, 7, 26, 2, 2, 442, 444, 5,
	138, 70, 2, 443, 440, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 686, 3, 2,
	2, 2, 445, 446, 7, 167, 2, 2, 446, 450, 7, 155, 2, 2, 447, 451, 7, 15,
	2, 2, 448, 451, 7, 120, 2, 2, 449, 451, 5, 144, 73, 2, 450, 447, 3, 2,
	2, 2, 450, 448, 3, 2, 2, 2, 450, 449, 3, 2, 2, 2, 451, 686, 3, 2, 2, 2,
	452, 463, 7, 78, 2, 2, 453, 458, 5, 134, 68, 2, 454, 455, 7, 6, 2, 2, 455,
	457, 5, 134, 68, 2, 456, 454, 3, 2, 2, 2, 457, 460, 3, 2, 2, 2, 458, 456,
	3, 2, 2, 2, 458, 459, 3, 2, 2, 2, 459, 464, 3, 2, 2, 2, 460, 458, 3, 2,
	2, 2, 461, 462, 7, 15, 2, 2, 462, 464, 7, 140, 2, 2, 463, 453, 3, 2, 2,
	2, 463, 461, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 467, 7, 126, 2, 2,
	466, 468, 7, 176, 2, 2, 467, 466, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468,
	469, 3, 2, 2, 2, 469, 470, 5, 136, 69, 2, 470, 471, 7, 183, 2, 2, 471,
	475, 5, 140, 71, 2, 472, 473, 7, 202, 2, 2, 473, 474, 7, 78, 2, 2, 474,
	476, 7, 128, 2, 2, 475, 472, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476, 686,
	3, 2, 2, 2, 477, 481, 7, 153, 2, 2, 478, 479, 7, 78, 2, 2, 479, 480, 7,
	128, 2, 2, 480, 482, 7, 72, 2, 2, 481, 478, 3, 2, 2, 2, 481, 482, 3, 2,
	2, 2, 482, 493, 3, 2, 2, 2, 483, 488, 5, 134, 68, 2, 484, 485, 7, 6, 2,
	2, 485, 487, 5, 134, 68, 2, 486, 484, 3, 2, 2, 2, 487, 490, 3, 2, 2, 2,
	488, 486, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489, 494, 3, 2, 2, 2, 490,
	488, 3, 2, 2, 2, 491, 492, 7, 15, 2, 2, 492, 494, 7, 140, 2, 2, 493, 483,
	3, 2, 2, 2, 493, 491, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 497, 7, 126,
	2, 2, 496, 498, 7, 176, 2, 2, 497, 496, 3, 2, 2, 2, 497, 498, 3, 2, 2,
	2, 498, 499, 3, 2, 2, 2, 499, 500, 5, 136, 69, 2, 500, 501, 7, 74, 2, 2,
	501, 502, 5, 140, 71, 2, 502, 686, 3, 2, 2, 2, 503, 504, 7, 169, 2, 2,
	504, 510, 7, 80, 2, 2, 505, 507, 7, 126, 2, 2, 506, 508, 7, 176, 2, 2,
	507, 506, 3, 2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509,
	511, 5, 136, 69, 2, 510, 505, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 686,
	3, 2, 2, 2, 512, 514, 7, 66, 2, 2, 513, 515, 7, 17, 2, 2, 514, 513, 3,
	2, 2, 2, 514, 515, 3, 2, 2, 2, 515, 517, 3, 2, 2, 2, 516, 518, 7, 198,
	2, 2, 517, 516, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 530, 3, 2, 2, 2,
	519, 520, 7, 4, 2, 2, 520, 525, 5, 126, 64, 2, 521, 522, 7, 6, 2, 2, 522,
	524, 5, 126, 64, 2, 523, 521, 3, 2, 2, 2, 524, 527, 3, 2, 2, 2, 525, 523,
	3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526, 528, 3, 2, 2, 2, 527, 525, 3, 2,
	2, 2, 528, 529, 7, 5, 2, 2, 529, 531, 3, 2, 2, 2, 530, 519, 3, 2, 2, 2,
	530, 531, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 686, 5, 8, 5, 2, 533,
	534, 7, 169, 2, 2, 534, 535, 7, 39, 2, 2, 535, 536, 7, 176, 2, 2, 536,
	686, 5, 136, 69, 2, 537, 538, 7, 169, 2, 2, 538, 539, 7, 39, 2, 2, 539,
	540, 7, 199, 2, 2, 540, 686, 5, 136, 69, 2, 541, 542, 7, 169, 2, 2, 542,
	543, 7, 39, 2, 2, 543, 544, 7, 76, 2, 2, 544, 546, 5, 136, 69, 2, 545,
	547, 5, 108, 55, 2, 546, 545, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 686,
	3, 2, 2, 2, 548, 549, 7, 169, 2, 2, 549, 552, 7, 177, 2, 2, 550, 551, 9,
	3, 2, 2, 551, 553, 5, 136, 69, 2, 552, 550, 3, 2, 2, 2, 552, 553, 3, 2,
	2, 2, 553, 560, 3, 2, 2, 2, 554, 555, 7, 106, 2, 2, 555, 558, 7, 12, 2,
	2, 556, 557, 7, 61, 2, 2, 557, 559, 7, 12, 2, 2, 558, 556, 3, 2, 2, 2,
	558, 559, 3, 2, 2, 2, 559, 561, 3, 2, 2, 2, 560, 554, 3, 2, 2, 2, 560,
	561, 3, 2, 2, 2, 561, 686, 3, 2, 2, 2, 562, 563, 7, 169, 2, 2, 563, 566,
	7, 162, 2, 2, 564, 565, 9, 3, 2, 2, 565, 567, 5, 144, 73, 2, 566, 564,
	3, 2, 2, 2, 566, 567, 3, 2, 2, 2, 567, 574, 3, 2, 2, 2, 568, 569, 7, 106,
	2, 2, 569, 572, 7, 12, 2, 2, 570, 571, 7, 61, 2, 2, 571, 573, 7, 12, 2,
	2, 572, 570, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 575, 3, 2, 2, 2, 574,
	568, 3, 2, 2, 2, 574, 575, 3, 2, 2, 2, 575, 686, 3, 2, 2, 2, 576, 577,
	7, 169, 2, 2, 577, 580, 7, 32, 2, 2, 578, 579, 7, 106, 2, 2, 579, 581,
	7, 12, 2, 2, 580, 578, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 686, 3, 2,
	2, 2, 582, 583, 7, 169, 2, 2, 583, 584, 7, 34, 2, 2, 584, 585, 9, 3, 2,
	2, 585, 686, 5, 136, 69, 2, 586, 587, 7, 169, 2, 2, 587, 588, 7, 173, 2,
	2, 588, 589, 7, 72, 2, 2, 589, 686, 5, 136, 69, 2, 590, 591, 7, 169, 2,
	2, 591, 592, 7, 173, 2, 2, 592, 593, 7, 72, 2, 2, 593, 594, 7, 4, 2, 2,
	594, 595, 5, 52, 27, 2, 595, 596, 7, 5, 2, 2, 596, 686, 3, 2, 2, 2, 597,
	599, 7, 169, 2, 2, 598, 600, 7, 42, 2, 2, 599, 598, 3, 2, 2, 2, 599, 600,
	3, 2, 2, 2, 600, 601, 3, 2, 2, 2, 601, 604, 7, 156, 2, 2, 602, 603, 9,
	3, 2, 2, 603, 605, 5, 144, 73, 2, 604, 602, 3, 2, 2, 2, 604, 605, 3, 2,
	2, 2, 605, 686, 3, 2, 2, 2, 606, 607, 7, 169, 2, 2, 607, 608, 7, 155, 2,
	2, 608, 611, 7, 80, 2, 2, 609, 610, 9, 3, 2, 2, 610, 612, 5, 144, 73, 2,
	611, 609, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2, 612, 686, 3, 2, 2, 2, 613,
	614, 7, 54, 2, 2, 614, 686, 5, 136, 69, 2, 615, 616, 7, 53, 2, 2, 616,
	686, 5, 136, 69, 2, 617, 618, 7, 169, 2, 2, 618, 625, 7, 77, 2, 2, 619,
	620, 7, 106, 2, 2, 620, 623, 7, 12, 2, 2, 621, 622, 7, 61, 2, 2, 622, 624,
	7, 12, 2, 2, 623, 621, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 626, 3, 2,
	2, 2, 625, 619, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 686, 3, 2, 2, 2,
	627, 628, 7, 169, 2, 2, 628, 686, 7, 166, 2, 2, 629, 630, 7, 167, 2, 2,
	630, 631, 7, 166, 2, 2, 631, 632, 5, 136, 69, 2, 632, 633, 7, 207, 2, 2,
	633, 634, 5, 82, 42, 2, 634, 686, 3, 2, 2, 2, 635, 636, 7, 148, 2, 2, 636,
	637, 7, 166, 2, 2, 637, 686, 5, 136, 69, 2, 638, 639, 7, 172, 2, 2, 639,
	648, 7, 184, 2, 2, 640, 645, 5, 128, 65, 2, 641, 642, 7, 6, 2, 2, 642,
	644, 5, 128, 65, 2, 643, 641, 3, 2, 2, 2, 644, 647, 3, 2, 2, 2, 645, 643,
	3, 2, 2, 2, 645, 646, 3, 2, 2, 2, 646, 649, 3, 2, 2, 2, 647, 645, 3, 2,
	2, 2, 648, 640, 3, 2, 2, 2, 648, 649, 3, 2, 2, 2, 649, 686, 3, 2, 2, 2,
	650, 652, 7, 36, 2, 2, 651, 653, 7, 203, 2, 2, 652, 651, 3, 2, 2, 2, 652,
	653, 3, 2, 2, 2, 653, 686, 3, 2, 2, 2, 654, 656, 7, 157, 2, 2, 655, 657,
	7, 203, 2, 2, 656, 655, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 686, 3,
	2, 2, 2, 658, 659, 7, 139, 2, 2, 659, 660, 5, 144, 73, 2, 660, 661, 7,
	74, 2, 2, 661, 662, 5, 8, 5, 2, 662, 686, 3, 2, 2, 2, 663, 664, 7, 51,
	2, 2, 664, 665, 7, 139, 2, 2, 665, 686, 5, 144, 73, 2, 666, 667, 7, 64,
	2, 2, 667, 677, 5, 144, 73, 2, 668, 669, 7, 195, 2, 2, 669, 674, 5, 82,
	42, 2, 670, 671, 7, 6, 2, 2, 671, 673, 5, 82, 42, 2, 672, 670, 3, 2, 2,
	2, 673, 676, 3, 2, 2, 2, 674, 672, 3, 2, 2, 2, 674, 675, 3, 2, 2, 2, 675,
	678, 3, 2, 2, 2, 676, 674, 3, 2, 2, 2, 677, 668, 3, 2, 2, 2, 677, 678,
	3, 2, 2, 2, 678, 686, 3, 2, 2, 2, 679, 680, 7, 54, 2, 2, 680, 681, 7, 91,
	2, 2, 681, 686, 5, 144, 73, 2, 682, 683, 7, 54, 2, 2, 683, 684, 7, 133,
	2, 2, 684, 686, 5, 144, 73, 2, 685, 159, 3, 2, 2, 2, 685, 160, 3, 2, 2,
	2, 685, 162, 3, 2, 2, 2, 685, 167, 3, 2, 2, 2, 685, 179, 3, 2, 2, 2, 685,
	189, 3, 2, 2, 2, 685, 196, 3, 2, 2, 2, 685, 230, 3, 2, 2, 2, 685, 256,
	3, 2, 2, 2, 685, 263, 3, 2, 2, 2, 685, 271, 3, 2, 2, 2, 685, 278, 3, 2,
	2, 2, 685, 285, 3, 2, 2, 2, 685, 294, 3, 2, 2, 2, 685, 301, 3, 2, 2, 2,
	685, 308, 3, 2, 2, 2, 685, 314, 3, 2, 2, 2, 685, 324, 3, 2, 2, 2, 685,
	331, 3, 2, 2, 2, 685, 359, 3, 2, 2, 2, 685, 367, 3, 2, 2, 2, 685, 377,
	3, 2, 2, 2, 685, 392, 3, 2, 2, 2, 685, 400, 3, 2, 2, 2, 685, 403, 3, 2,
	2, 2, 685, 424, 3, 2, 2, 2, 685, 445, 3, 2, 2, 2, 685, 452, 3, 2, 2, 2,
	685, 477, 3, 2, 2, 2, 685, 503, 3, 2, 2, 2, 685, 512, 3, 2, 2, 2, 685,
	533, 3, 2, 2, 2, 685, 537, 3, 2, 2, 2, 685, 541, 3, 2, 2, 2, 685, 548,
	3, 2, 2, 2, 685, 562, 3, 2, 2, 2, 685, 576, 3, 2, 2, 2, 685, 582, 3, 2,
	2, 2, 685, 586, 3, 2, 2, 2, 685, 590, 3, 2, 2, 2, 685, 597, 3, 2, 2, 2,
	685, 606, 3, 2, 2, 2, 685, 613, 3, 2, 2, 2, 685, 615, 3, 2, 2, 2, 685,
	617, 3, 2, 2, 2, 685, 627, 3, 2, 2, 2, 685, 629, 3, 2, 2, 2, 685, 635,
	3, 2, 2, 2, 685, 638, 3, 2, 2, 2, 685, 650, 3, 2, 2, 2, 685, 654, 3, 2,
	2, 2, 685, 658, 3, 2, 2, 2, 685, 663, 3, 2, 2, 2, 685, 666, 3, 2, 2, 2,
	685, 679, 3, 2, 2, 2, 685, 682, 3, 2, 2, 2, 686, 9, 3, 2, 2, 2, 687, 689,
	5, 12, 7, 2, 688, 687, 3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 690, 3, 2,
	2, 2, 690, 691, 5, 44, 23, 2, 691, 11, 3, 2, 2, 2, 692, 694, 7, 202, 2,
	2, 693, 695, 7, 144, 2, 2, 694, 693, 3, 2, 2, 2, 694, 695, 3, 2, 2, 2,
	695, 696, 3, 2, 2, 2, 696, 701, 5, 60, 31, 2, 697, 698, 7, 6, 2, 2, 698,
	700, 5, 60, 31, 2, 699, 697, 3, 2, 2, 2, 700, 703, 3, 2, 2, 2, 701, 699,
	3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 13, 3, 2, 2, 2, 703, 701, 3, 2,
	2, 2, 704, 707, 5, 16, 9, 2, 705, 707, 5, 18, 10, 2, 706, 704, 3, 2, 2,
	2, 706, 705, 3, 2, 2, 2, 707, 15, 3, 2, 2, 2, 708, 709, 5, 144, 73, 2,
	709, 712, 5, 110, 56, 2, 710, 711, 7, 122, 2, 2, 711, 713, 7, 123, 2, 2,
	712, 710, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 716, 3, 2, 2, 2, 714,
	715, 7, 35, 2, 2, 715, 717, 7, 12, 2, 2, 716, 714, 3, 2, 2, 2, 716, 717,
	3, 2, 2, 2, 717, 720, 3, 2, 2, 2, 718, 719, 7, 202, 2, 2, 719, 721, 5,
	20, 11, 2, 720, 718, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 17, 3, 2, 2,
	2, 722, 723, 7, 106, 2, 2, 723, 726, 5, 136, 69, 2, 724, 725, 9, 4, 2,
	2, 725, 727, 7, 141, 2, 2, 726, 724, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2,
	727, 19, 3, 2, 2, 2, 728, 729, 7, 4, 2, 2, 729, 734, 5, 22, 12, 2, 730,
	731, 7, 6, 2, 2, 731, 733, 5, 22, 12, 2, 732, 730, 3, 2, 2, 2, 733, 736,
	3, 2, 2, 2, 734, 732, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 737, 3, 2,
	2, 2, 736, 734, 3, 2, 2, 2, 737, 738, 7, 5, 2, 2, 738, 21, 3, 2, 2, 2,
	739, 740, 5, 144, 73, 2, 740, 741, 7, 207, 2, 2, 741, 742, 5, 82, 42, 2,
	742, 23, 3, 2, 2, 2, 743, 744, 5, 144, 73, 2, 744, 745, 5, 110, 56, 2,
	745, 25, 3, 2, 2, 2, 746, 748, 5, 28, 15, 2, 747, 746, 3, 2, 2, 2, 748,
	751, 3, 2, 2, 2, 749, 747, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 27, 3,
	2, 2, 2, 751, 749, 3, 2, 2, 2, 752, 753, 7, 101, 2, 2, 753, 757, 5, 38,
	20, 2, 754, 757, 5, 40, 21, 2, 755, 757, 5, 42, 22, 2, 756, 752, 3, 2,
	2, 2, 756, 754, 3, 2, 2, 2, 756, 755, 3, 2, 2, 2, 757, 29, 3, 2, 2, 2,
	758, 760, 5, 32, 17, 2, 759, 758, 3, 2, 2, 2, 760, 763, 3, 2, 2, 2, 761,
	759, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 31, 3, 2, 2, 2, 763, 761, 3,
	2, 2, 2, 764, 765, 5, 42, 22, 2, 765, 33, 3, 2, 2, 2, 766, 767, 5, 36,
	19, 2, 767, 35, 3, 2, 2, 2, 768, 769, 7, 151, 2, 2, 769, 770, 5, 82, 42,
	2, 770, 37, 3, 2, 2, 2, 771, 772, 7, 171, 2, 2, 772, 39, 3, 2, 2, 2, 773,
	777, 7, 55, 2, 2, 774, 775, 7, 122, 2, 2, 775, 777, 7, 55, 2, 2, 776, 773,
	3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 777, 41, 3, 2, 2, 2, 778, 779, 7, 152,
	2, 2, 779, 780, 7, 123, 2, 2, 780, 781, 7, 126, 2, 2, 781, 782, 7, 123,
	2, 2, 782, 788, 7, 91, 2, 2, 783, 784, 7, 28, 2, 2, 784, 785, 7, 126, 2,
	2, 785, 786, 7, 123, 2, 2, 786, 788, 7, 91, 2, 2, 787, 778, 3, 2, 2, 2,
	787, 783, 3, 2, 2, 2, 788, 43, 3, 2, 2, 2, 789, 800, 5, 46, 24, 2, 790,
	791, 7, 130, 2, 2, 791, 792, 7, 26, 2, 2, 792, 797, 5, 50, 26, 2, 793,
	794, 7, 6, 2, 2, 794, 796, 5, 50, 26, 2, 795, 793, 3, 2, 2, 2, 796, 799,
	3, 2, 2, 2, 797, 795, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 801, 3, 2,
	2, 2, 799, 797, 3, 2, 2, 2, 800, 790, 3, 2, 2, 2, 800, 801, 3, 2, 2, 2,
	801, 804, 3, 2, 2, 2, 802, 803, 7, 107, 2, 2, 803, 805, 9, 5, 2, 2, 804,
	802, 3, 2, 2, 2, 804, 805, 3, 2, 2, 2, 805, 45, 3, 2, 2, 2, 806, 807, 8,
	24, 1, 2, 807, 808, 5, 48, 25, 2, 808, 823, 3, 2, 2, 2, 809, 810, 12, 4,
	2, 2, 810, 812, 7, 93, 2, 2, 811, 813, 5, 62, 32, 2, 812, 811, 3, 2, 2,
	2, 812, 813, 3, 2, 2, 2, 813, 814, 3, 2, 2, 2, 814, 822, 5, 46, 24, 5,
	815, 816, 12, 3, 2, 2, 816, 818, 9, 6, 2, 2, 817, 819, 5, 62, 32, 2, 818,
	817, 3, 2, 2, 2, 818, 819, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 822,
	5, 46, 24, 4, 821, 809, 3, 2, 2, 2, 821, 815, 3, 2, 2, 2, 822, 825, 3,
	2, 2, 2, 823, 821, 3, 2, 2, 2, 823, 824, 3, 2, 2, 2, 824, 47, 3, 2, 2,
	2, 825, 823, 3, 2, 2, 2, 826, 843, 5, 52, 27, 2, 827, 828, 7, 176, 2, 2,
	828, 843, 5, 136, 69, 2, 829, 830, 7, 197, 2, 2, 830, 835, 5, 82, 42, 2,
	831, 832, 7, 6, 2, 2, 832, 834, 5, 82, 42, 2, 833, 831, 3, 2, 2, 2, 834,
	837, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2, 836, 843,
	3, 2, 2, 2, 837, 835, 3, 2, 2, 2, 838, 839, 7, 4, 2, 2, 839, 840, 5, 44,
	23, 2, 840, 841, 7, 5, 2, 2, 841, 843, 3, 2, 2, 2, 842, 826, 3, 2, 2, 2,
	842, 827, 3, 2, 2, 2, 842, 829, 3, 2, 2, 2, 842, 838, 3, 2, 2, 2, 843,
	49, 3, 2, 2, 2, 844, 846, 5, 82, 42, 2, 845, 847, 9, 7, 2, 2, 846, 845,
	3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 850, 3, 2, 2, 2, 848, 849, 7, 125,
	2, 2, 849, 851, 9, 8, 2, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2, 2, 2,
	851, 51, 3, 2, 2, 2, 852, 854, 7, 164, 2, 2, 853, 855, 5, 62, 32, 2, 854,
	853, 3, 2, 2, 2, 854, 855, 3, 2, 2, 2, 855, 856, 3, 2, 2, 2, 856, 861,
	5, 64, 33, 2, 857, 858, 7, 6, 2, 2, 858, 860, 5, 64, 33, 2, 859, 857, 3,
	2, 2, 2, 860, 863, 3, 2, 2, 2, 861, 859, 3, 2, 2, 2, 861, 862, 3, 2, 2,
	2, 862, 873, 3, 2, 2, 2, 863, 861, 3, 2, 2, 2, 864, 865, 7, 74, 2, 2, 865,
	870, 5, 66, 34, 2, 866, 867, 7, 6, 2, 2, 867, 869, 5, 66, 34, 2, 868, 866,
	3, 2, 2, 2, 869, 872, 3, 2, 2, 2, 870, 868, 3, 2, 2, 2, 870, 871, 3, 2,
	2, 2, 871, 874, 3, 2, 2, 2, 872, 870, 3, 2, 2, 2, 873, 864, 3, 2, 2, 2,
	873, 874, 3, 2, 2, 2, 874, 877, 3, 2, 2, 2, 875, 876, 7, 201, 2, 2, 876,
	878, 5, 84, 43, 2, 877, 875, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 882,
	3, 2, 2, 2, 879, 880, 7, 82, 2, 2, 880, 881, 7, 26, 2, 2, 881, 883, 5,
	54, 28, 2, 882, 879, 3, 2, 2, 2, 882, 883, 3, 2, 2, 2, 883, 886, 3, 2,
	2, 2, 884, 885, 7, 84, 2, 2, 885, 887, 5, 84, 43, 2, 886, 884, 3, 2, 2,
	2, 886, 887, 3, 2, 2, 2, 887, 53, 3, 2, 2, 2, 888, 890, 5, 62, 32, 2, 889,
	888, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 891, 3, 2, 2, 2, 891, 896,
	5, 56, 29, 2, 892, 893, 7, 6, 2, 2, 893, 895, 5, 56, 29, 2, 894, 892, 3,
	2, 2, 2, 895, 898, 3, 2, 2, 2, 896, 894, 3, 2, 2, 2, 896, 897, 3, 2, 2,
	2, 897, 55, 3, 2, 2, 2, 898, 896, 3, 2, 2, 2, 899, 940, 5, 58, 30, 2, 900,
	901, 7, 158, 2, 2, 901, 910, 7, 4, 2, 2, 902, 907, 5, 82, 42, 2, 903, 904,
	7, 6, 2, 2, 904, 906, 5, 82, 42, 2, 905, 903, 3, 2, 2, 2, 906, 909, 3,
	2, 2, 2, 907, 905, 3, 2, 2, 2, 907, 908, 3, 2, 2, 2, 908, 911, 3, 2, 2,
	2, 909, 907, 3, 2, 2, 2, 910, 902, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911,
	912, 3, 2, 2, 2, 912, 940, 7, 5, 2, 2, 913, 914, 7, 41, 2, 2, 914, 923,
	7, 4, 2, 2, 915, 920, 5, 82, 42, 2, 916, 917, 7, 6, 2, 2, 917, 919, 5,
	82, 42, 2, 918, 916, 3, 2, 2, 2, 919, 922, 3, 2, 2, 2, 920, 918, 3, 2,
	2, 2, 920, 921, 3, 2, 2, 2, 921, 924, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2,
	923, 915, 3, 2, 2, 2, 923, 924, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925,
	940, 7, 5, 2, 2, 926, 927, 7, 83, 2, 2, 927, 928, 7, 168, 2, 2, 928, 929,
	7, 4, 2, 2, 929, 934, 5, 58, 30, 2, 930, 931, 7, 6, 2, 2, 931, 933, 5,
	58, 30, 2, 932, 930, 3, 2, 2, 2, 933, 936, 3, 2, 2, 2, 934, 932, 3, 2,
	2, 2, 934, 935, 3, 2, 2, 2, 935, 937, 3, 2, 2, 2, 936, 934, 3, 2, 2, 2,
	937, 938, 7, 5, 2, 2, 938, 940, 3, 2, 2, 2, 939, 899, 3, 2, 2, 2, 939,
	900, 3, 2, 2, 2, 939, 913, 3, 2, 2, 2, 939, 926, 3, 2, 2, 2, 940, 57, 3,
	2, 2, 2, 941, 950, 7, 4, 2, 2, 942, 947, 5, 82, 42, 2, 943, 944, 7, 6,
	2, 2, 944, 946, 5, 82, 42, 2, 945, 943, 3, 2, 2, 2, 946, 949, 3, 2, 2,
	2, 947, 945, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948, 951, 3, 2, 2, 2, 949,
	947, 3, 2, 2, 2, 950, 942, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951, 952,
	3, 2, 2, 2, 952, 955, 7, 5, 2, 2, 953, 955, 5, 82, 42, 2, 954, 941, 3,
	2, 2, 2, 954, 953, 3, 2, 2, 2, 955, 59, 3, 2, 2, 2, 956, 958, 5, 144, 73,
	2, 957, 959, 5, 78, 40, 2, 958, 957, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2,
	959, 960, 3, 2, 2, 2, 960, 961, 7, 21, 2, 2, 961, 962, 7, 4, 2, 2, 962,
	963, 5, 10, 6, 2, 963, 964, 7, 5, 2, 2, 964, 61, 3, 2, 2, 2, 965, 966,
	9, 9, 2, 2, 966, 63, 3, 2, 2, 2, 967, 972, 5, 82, 42, 2, 968, 970, 7, 21,
	2, 2, 969, 968, 3, 2, 2, 2, 969, 970, 3, 2, 2, 2, 970, 971, 3, 2, 2, 2,
	971, 973, 5, 144, 73, 2, 972, 969, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2, 973,
	980, 3, 2, 2, 2, 974, 975, 5, 136, 69, 2, 975, 976, 7, 3, 2, 2, 976, 977,
	7, 215, 2, 2, 977, 980, 3, 2, 2, 2, 978, 980, 7, 215, 2, 2, 979, 967, 3,
	2, 2, 2, 979, 974, 3, 2, 2, 2, 979, 978, 3, 2, 2, 2, 980, 65, 3, 2, 2,
	2, 981, 982, 8, 34, 1, 2, 982, 983, 5, 72, 37, 2, 983, 1002, 3, 2, 2, 2,
	984, 998, 12, 4, 2, 2, 985, 986, 7, 40, 2, 2, 986, 987, 7, 100, 2, 2, 987,
	999, 5, 72, 37, 2, 988, 989, 5, 68, 35, 2, 989, 990, 7, 100, 2, 2, 990,
	991, 5, 66, 34, 2, 991, 992, 5, 70, 36, 2, 992, 999, 3, 2, 2, 2, 993, 994,
	7, 114, 2, 2, 994, 995, 5, 68, 35, 2, 995, 996, 7, 100, 2, 2, 996, 997,
	5, 72, 37, 2, 997, 999, 3, 2, 2, 2, 998, 985, 3, 2, 2, 2, 998, 988, 3,
	2, 2, 2, 998, 993, 3, 2, 2, 2, 999, 1001, 3, 2, 2, 2, 1000, 984, 3, 2,
	2, 2, 1001, 1004, 3, 2, 2, 2, 1002, 1000, 3, 2, 2, 2, 1002, 1003, 3, 2,
	2, 2, 1003, 67, 3, 2, 2, 2, 1004, 1002, 3, 2, 2, 2, 1005, 1007, 7, 90,
	2, 2, 1006, 1005, 3, 2, 2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 1021, 3, 2,
	2, 2, 1008, 1010, 7, 104, 2, 2, 1009, 1011, 7, 132, 2, 2, 1010, 1009, 3,
	2, 2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 1021, 3, 2, 2, 2, 1012, 1014, 7,
	154, 2, 2, 1013, 1015, 7, 132, 2, 2, 1014, 1013, 3, 2, 2, 2, 1014, 1015,
	3, 2, 2, 2, 1015, 1021, 3, 2, 2, 2, 1016, 1018, 7, 75, 2, 2, 1017, 1019,
	7, 132, 2, 2, 1018, 1017, 3, 2, 2, 2, 1018, 1019, 3, 2, 2, 2, 1019, 1021,
	3, 2, 2, 2, 1020, 1006, 3, 2, 2, 2, 1020, 1008, 3, 2, 2, 2, 1020, 1012,
	3, 2, 2, 2, 1020, 1016, 3, 2, 2, 2, 1021, 69, 3, 2, 2, 2, 1022, 1023, 7,
	126, 2, 2, 1023, 1037, 5, 84, 43, 2, 1024, 1025, 7, 195, 2, 2, 1025, 1026,
	7, 4, 2, 2, 1026, 1031, 5, 144, 73, 2, 1027, 1028, 7, 6, 2, 2, 1028, 1030,
	5, 144, 73, 2, 1029, 1027, 3, 2, 2, 2, 1030, 1033, 3, 2, 2, 2, 1031, 1029,
	3, 2, 2, 2, 1031, 1032, 3, 2, 2, 2, 1032, 1034, 3, 2, 2, 2, 1033, 1031,
	3, 2, 2, 2, 1034, 1035, 7, 5, 2, 2, 1035, 1037, 3, 2, 2, 2, 1036, 1022,
	3, 2, 2, 2, 1036, 1024, 3, 2, 2, 2, 1037, 71, 3, 2, 2, 2, 1038, 1045, 5,
	76, 39, 2, 1039, 1040, 7, 178, 2, 2, 1040, 1041, 5, 74, 38, 2, 1041, 1042,
	7, 4, 2, 2, 1042, 1043, 5, 82, 42, 2, 1043, 1044, 7, 5, 2, 2, 1044, 1046,
	3, 2, 2, 2, 1045, 1039, 3, 2, 2, 2, 1045, 1046, 3, 2, 2, 2, 1046, 73, 3,
	2, 2, 2, 1047, 1048, 9, 10, 2, 2, 1048, 75, 3, 2, 2, 2, 1049, 1057, 5,
	80, 41, 2, 1050, 1052, 7, 21, 2, 2, 1051, 1050, 3, 2, 2, 2, 1051, 1052,
	3, 2, 2, 2, 1052, 1053, 3, 2, 2, 2, 1053, 1055, 5, 144, 73, 2, 1054, 1056,
	5, 78, 40, 2, 1055, 1054, 3, 2, 2, 2, 1055, 1056, 3, 2, 2, 2, 1056, 1058,
	3, 2, 2, 2, 1057, 1051, 3, 2, 2, 2, 1057, 1058, 3, 2, 2, 2, 1058, 77, 3,
	2, 2, 2, 1059, 1060, 7, 4, 2, 2, 1060, 1065, 5, 144, 73, 2, 1061, 1062,
	7, 6, 2, 2, 1062, 1064, 5, 144, 73, 2, 1063, 1061, 3, 2, 2, 2, 1064, 1067,
	3, 2, 2, 2, 1065, 1063, 3, 2, 2, 2, 1065, 1066, 3, 2, 2, 2, 1066, 1068,
	3, 2, 2, 2, 1067, 1065, 3, 2, 2, 2, 1068, 1069, 7, 5, 2, 2, 1069, 79, 3,
	2, 2, 2, 1070, 1100, 5, 136, 69, 2, 1071, 1072, 7, 4, 2, 2, 1072, 1073,
	5, 10, 6, 2, 1073, 1074, 7, 5, 2, 2, 1074, 1100, 3, 2, 2, 2, 1075, 1076,
	7, 192, 2, 2, 1076, 1077, 7, 4, 2, 2, 1077, 1082, 5, 82, 42, 2, 1078, 1079,
	7, 6, 2, 2, 1079, 1081, 5, 82, 42, 2, 1080, 1078, 3, 2, 2, 2, 1081, 1084,
	3, 2, 2, 2, 1082, 1080, 3, 2, 2, 2, 1082, 1083, 3, 2, 2, 2, 1083, 1085,
	3, 2, 2, 2, 1084, 1082, 3, 2, 2, 2, 1085, 1088, 7, 5, 2, 2, 1086, 1087,
	7, 202, 2, 2, 1087, 1089, 7, 131, 2, 2, 1088, 1086, 3, 2, 2, 2, 1088, 1089,
	3, 2, 2, 2, 1089, 1100, 3, 2, 2, 2, 1090, 1091, 7, 103, 2, 2, 1091, 1092,
	7, 4, 2, 2, 1092, 1093, 5, 10, 6, 2, 1093, 1094, 7, 5, 2, 2, 1094, 1100,
	3, 2, 2, 2, 1095, 1096, 7, 4, 2, 2, 1096, 1097, 5, 66, 34, 2, 1097, 1098,
	7, 5, 2, 2, 1098, 1100, 3, 2, 2, 2, 1099, 1070, 3, 2, 2, 2, 1099, 1071,
	3, 2, 2, 2, 1099, 1075, 3, 2, 2, 2, 1099, 1090, 3, 2, 2, 2, 1099, 1095,
	3, 2, 2, 2, 1100, 81, 3, 2, 2, 2, 1101, 1102, 5, 84, 43, 2, 1102, 83, 3,
	2, 2, 2, 1103, 1104, 8, 43, 1, 2, 1104, 1106, 5, 88, 45, 2, 1105, 1107,
	5, 86, 44, 2, 1106, 1105, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107, 1111,
	3, 2, 2, 2, 1108, 1109, 7, 122, 2, 2, 1109, 1111, 5, 84, 43, 5, 1110, 1103,
	3, 2, 2, 2, 1110, 1108, 3, 2, 2, 2, 1111, 1120, 3, 2, 2, 2, 1112, 1113,
	12, 4, 2, 2, 1113, 1114, 7, 18, 2, 2, 1114, 1119, 5, 84, 43, 5, 1115, 1116,
	12, 3, 2, 2, 1116, 1117, 7, 129, 2, 2, 1117, 1119, 5, 84, 43, 4, 1118,
	1112, 3, 2, 2, 2, 1118, 1115, 3, 2, 2, 2, 1119, 1122, 3, 2, 2, 2, 1120,
	1118, 3, 2, 2, 2, 1120, 1121, 3, 2, 2, 2, 1121, 85, 3, 2, 2, 2, 1122, 1120,
	3, 2, 2, 2, 1123, 1124, 5, 96, 49, 2, 1124, 1125, 5, 88, 45, 2, 1125, 1185,
	3, 2, 2, 2, 1126, 1127, 5, 96, 49, 2, 1127, 1128, 5, 98, 50, 2, 1128, 1129,
	7, 4, 2, 2, 1129, 1130, 5, 10, 6, 2, 1130, 1131, 7, 5, 2, 2, 1131, 1185,
	3, 2, 2, 2, 1132, 1134, 7, 122, 2, 2, 1133, 1132, 3, 2, 2, 2, 1133, 1134,
	3, 2, 2, 2, 1134, 1135, 3, 2, 2, 2, 1135, 1136, 7, 25, 2, 2, 1136, 1137,
	5, 88, 45, 2, 1137, 1138, 7, 18, 2, 2, 1138, 1139, 5, 88, 45, 2, 1139,
	1185, 3, 2, 2, 2, 1140, 1142, 7, 122, 2, 2, 1141, 1140, 3, 2, 2, 2, 1141,
	1142, 3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1144, 7, 88, 2, 2, 1144,
	1145, 7, 4, 2, 2, 1145, 1150, 5, 82, 42, 2, 1146, 1147, 7, 6, 2, 2, 1147,
	1149, 5, 82, 42, 2, 1148, 1146, 3, 2, 2, 2, 1149, 1152, 3, 2, 2, 2, 1150,
	1148, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1153, 3, 2, 2, 2, 1152,
	1150, 3, 2, 2, 2, 1153, 1154, 7, 5, 2, 2, 1154, 1185, 3, 2, 2, 2, 1155,
	1157, 7, 122, 2, 2, 1156, 1155, 3, 2, 2, 2, 1156, 1157, 3, 2, 2, 2, 1157,
	1158, 3, 2, 2, 2, 1158, 1159, 7, 88, 2, 2, 1159, 1160, 7, 4, 2, 2, 1160,
	1161, 5, 10, 6, 2, 1161, 1162, 7, 5, 2, 2, 1162, 1185, 3, 2, 2, 2, 1163,
	1165, 7, 122, 2, 2, 1164, 1163, 3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165,
	1166, 3, 2, 2, 2, 1166, 1167, 7, 106, 2, 2, 1167, 1170, 5, 88, 45, 2, 1168,
	1169, 7, 61, 2, 2, 1169, 1171, 5, 88, 45, 2, 1170, 1168, 3, 2, 2, 2, 1170,
	1171, 3, 2, 2, 2, 1171, 1185, 3, 2, 2, 2, 1172, 1174, 7, 97, 2, 2, 1173,
	1175, 7, 122, 2, 2, 1174, 1173, 3, 2, 2, 2, 1174, 1175, 3, 2, 2, 2, 1175,
	1176, 3, 2, 2, 2, 1176, 1185, 7, 123, 2, 2, 1177, 1179, 7, 97, 2, 2, 1178,
	1180, 7, 122, 2, 2, 1179, 1178, 3, 2, 2, 2, 1179, 1180, 3, 2, 2, 2, 1180,
	1181, 3, 2, 2, 2, 1181, 1182, 7, 56, 2, 2, 1182, 1183, 7, 74, 2, 2, 1183,
	1185, 5, 88, 45, 2, 1184, 1123, 3, 2, 2, 2, 1184, 1126, 3, 2, 2, 2, 1184,
	1133, 3, 2, 2, 2, 1184, 1141, 3, 2, 2, 2, 1184, 1156, 3, 2, 2, 2, 1184,
	1164, 3, 2, 2, 2, 1184, 1172, 3, 2, 2, 2, 1184, 1177, 3, 2, 2, 2, 1185,
	87, 3, 2, 2, 2, 1186, 1187, 8, 45, 1, 2, 1187, 1191, 5, 90, 46, 2, 1188,
	1189, 9, 11, 2, 2, 1189, 1191, 5, 88, 45, 6, 1190, 1186, 3, 2, 2, 2, 1190,
	1188, 3, 2, 2, 2, 1191, 1206, 3, 2, 2, 2, 1192, 1193, 12, 5, 2, 2, 1193,
	1194, 9, 12, 2, 2, 1194, 1205, 5, 88, 45, 6, 1195, 1196, 12, 4, 2, 2, 1196,
	1197, 9, 11, 2, 2, 1197, 1205, 5, 88, 45, 5, 1198, 1199, 12, 3, 2, 2, 1199,
	1200, 7, 218, 2, 2, 1200, 1205, 5, 88, 45, 4, 1201, 1202, 12, 7, 2, 2,
	1202, 1203, 7, 23, 2, 2, 1203, 1205, 5, 94, 48, 2, 1204, 1192, 3, 2, 2,
	2, 1204, 1195, 3, 2, 2, 2, 1204, 1198, 3, 2, 2, 2, 1204, 1201, 3, 2, 2,
	2, 1205, 1208, 3, 2, 2, 2, 1206, 1204, 3, 2, 2, 2, 1206, 1207, 3, 2, 2,
	2, 1207, 89, 3, 2, 2, 2, 1208, 1206, 3, 2, 2, 2, 1209, 1210, 8, 46, 1,
	2, 1210, 1449, 7, 123, 2, 2, 1211, 1449, 5, 102, 52, 2, 1212, 1213, 5,
	144, 73, 2, 1213, 1214, 7, 12, 2, 2, 1214, 1449, 3, 2, 2, 2, 1215, 1216,
	7, 231, 2, 2, 1216, 1449, 7, 12, 2, 2, 1217, 1449, 5, 146, 74, 2, 1218,
	1449, 5, 100, 51, 2, 1219, 1449, 7, 12, 2, 2, 1220, 1449, 7, 221, 2, 2,
	1221, 1449, 7, 7, 2, 2, 1222, 1223, 7, 137, 2, 2, 1223, 1224, 7, 4, 2,
	2, 1224, 1225, 5, 88, 45, 2, 1225, 1226, 7, 88, 2, 2, 1226, 1227, 5, 88,
	45, 2, 1227, 1228, 7, 5, 2, 2, 1228, 1449, 3, 2, 2, 2, 1229, 1230, 7, 4,
	2, 2, 1230, 1233, 5, 82, 42, 2, 1231, 1232, 7, 6, 2, 2, 1232, 1234, 5,
	82, 42, 2, 1233, 1231, 3, 2, 2, 2, 1234, 1235, 3, 2, 2, 2, 1235, 1233,
	3, 2, 2, 2, 1235, 1236, 3, 2, 2, 2, 1236, 1237, 3, 2, 2, 2, 1237, 1238,
	7, 5, 2, 2, 1238, 1449, 3, 2, 2, 2, 1239, 1240, 7, 159, 2, 2, 1240, 1241,
	7, 4, 2, 2, 1241, 1246, 5, 82, 42, 2, 1242, 1243, 7, 6, 2, 2, 1243, 1245,
	5, 82, 42, 2, 1244, 1242, 3, 2, 2, 2, 1245, 1248, 3, 2, 2, 2, 1246, 1244,
	3, 2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 1249, 3, 2, 2, 2, 1248, 1246,
	3, 2, 2, 2, 1249, 1250, 7, 5, 2, 2, 1250, 1449, 3, 2, 2, 2, 1251, 1252,
	5, 136, 69, 2, 1252, 1253, 7, 4, 2, 2, 1253, 1254, 7, 215, 2, 2, 1254,
	1256, 7, 5, 2, 2, 1255, 1257, 5, 118, 60, 2, 1256, 1255, 3, 2, 2, 2, 1256,
	1257, 3, 2, 2, 2, 1257, 1259, 3, 2, 2, 2, 1258, 1260, 5, 120, 61, 2, 1259,
	1258, 3, 2, 2, 2, 1259, 1260, 3, 2, 2, 2, 1260, 1449, 3, 2, 2, 2, 1261,
	1262, 5, 136, 69, 2, 1262, 1274, 7, 4, 2, 2, 1263, 1265, 5, 62, 32, 2,
	1264, 1263, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265, 1266, 3, 2, 2, 2,
	1266, 1271, 5, 82, 42, 2, 1267, 1268, 7, 6, 2, 2, 1268, 1270, 5, 82, 42,
	2, 1269, 1267, 3, 2, 2, 2, 1270, 1273, 3, 2, 2, 2, 1271, 1269, 3, 2, 2,
	2, 1271, 1272, 3, 2, 2, 2, 1272, 1275, 3, 2, 2, 2, 1273, 1271, 3, 2, 2,
	2, 1274, 1264, 3, 2, 2, 2, 1274, 1275, 3, 2, 2, 2, 1275, 1286, 3, 2, 2,
	2, 1276, 1277, 7, 130, 2, 2, 1277, 1278, 7, 26, 2, 2, 1278, 1283, 5, 50,
	26, 2, 1279, 1280, 7, 6, 2, 2, 1280, 1282, 5, 50, 26, 2, 1281, 1279, 3,
	2, 2, 2, 1282, 1285, 3, 2, 2, 2, 1283, 1281, 3, 2, 2, 2, 1283, 1284, 3,
	2, 2, 2, 1284, 1287, 3, 2, 2, 2, 1285, 1283, 3, 2, 2, 2, 1286, 1276, 3,
	2, 2, 2, 1286, 1287, 3, 2, 2, 2, 1287, 1288, 3, 2, 2, 2, 1288, 1290, 7,
	5, 2, 2, 1289, 1291, 5, 118, 60, 2, 1290, 1289, 3, 2, 2, 2, 1290, 1291,
	3, 2, 2, 2, 1291, 1296, 3, 2, 2, 2, 1292, 1294, 5, 92, 47, 2, 1293, 1292,
	3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2, 1295, 1297,
	5, 120, 61, 2, 1296, 1293, 3, 2, 2, 2, 1296, 1297, 3, 2, 2, 2, 1297, 1449,
	3, 2, 2, 2, 1298, 1299, 5, 144, 73, 2, 1299, 1300, 7, 8, 2, 2, 1300, 1301,
	5, 82, 42, 2, 1301, 1449, 3, 2, 2, 2, 1302, 1311, 7, 4, 2, 2, 1303, 1308,
	5, 144, 73, 2, 1304, 1305, 7, 6, 2, 2, 1305, 1307, 5, 144, 73, 2, 1306,
	1304, 3, 2, 2, 2, 1307, 1310, 3, 2, 2, 2, 1308, 1306, 3, 2, 2, 2, 1308,
	1309, 3, 2, 2, 2, 1309, 1312, 3, 2, 2, 2, 1310, 1308, 3, 2, 2, 2, 1311,
	1303, 3, 2, 2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1313, 3, 2, 2, 2, 1313,
	1314, 7, 5, 2, 2, 1314, 1315, 7, 8, 2, 2, 1315, 1449, 5, 82, 42, 2, 1316,
	1317, 7, 4, 2, 2, 1317, 1318, 5, 10, 6, 2, 1318, 1319, 7, 5, 2, 2, 1319,
	1449, 3, 2, 2, 2, 1320, 1321, 7, 65, 2, 2, 1321, 1322, 7, 4, 2, 2, 1322,
	1323, 5, 10, 6, 2, 1323, 1324, 7, 5, 2, 2, 1324, 1449, 3, 2, 2, 2, 1325,
	1326, 7, 30, 2, 2, 1326, 1328, 5, 88, 45, 2, 1327, 1329, 5, 116, 59, 2,
	1328, 1327, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 1328, 3, 2, 2, 2,
	1330, 1331, 3, 2, 2, 2, 1331, 1334, 3, 2, 2, 2, 1332, 1333, 7, 59, 2, 2,
	1333, 1335, 5, 82, 42, 2, 1334, 1332, 3, 2, 2, 2, 1334, 1335, 3, 2, 2,
	2, 1335, 1336, 3, 2, 2, 2, 1336, 1337, 7, 60, 2, 2, 1337, 1449, 3, 2, 2,
	2, 1338, 1340, 7, 30, 2, 2, 1339, 1341, 5, 116, 59, 2, 1340, 1339, 3, 2,
	2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 1340, 3, 2, 2, 2, 1342, 1343, 3, 2,
	2, 2, 1343, 1346, 3, 2, 2, 2, 1344, 1345, 7, 59, 2, 2, 1345, 1347, 5, 82,
	42, 2, 1346, 1344, 3, 2, 2, 2, 1346, 1347, 3, 2, 2, 2, 1347, 1348, 3, 2,
	2, 2, 1348, 1349, 7, 60, 2, 2, 1349, 1449, 3, 2, 2, 2, 1350, 1351, 7, 31,
	2, 2, 1351, 1352, 7, 4, 2, 2, 1352, 1353, 5, 82, 42, 2, 1353, 1354, 7,
	21, 2, 2, 1354, 1355, 5, 110, 56, 2, 1355, 1356, 7, 5, 2, 2, 1356, 1449,
	3, 2, 2, 2, 1357, 1358, 7, 186, 2, 2, 1358, 1359, 7, 4, 2, 2, 1359, 1360,
	5, 82, 42, 2, 1360, 1361, 7, 21, 2, 2, 1361, 1362, 5, 110, 56, 2, 1362,
	1363, 7, 5, 2, 2, 1363, 1449, 3, 2, 2, 2, 1364, 1365, 7, 20, 2, 2, 1365,
	1374, 7, 9, 2, 2, 1366, 1371, 5, 82, 42, 2, 1367, 1368, 7, 6, 2, 2, 1368,
	1370, 5, 82, 42, 2, 1369, 1367, 3, 2, 2, 2, 1370, 1373, 3, 2, 2, 2, 1371,
	1369, 3, 2, 2, 2, 1371, 1372, 3, 2, 2, 2, 1372, 1375, 3, 2, 2, 2, 1373,
	1371, 3, 2, 2, 2, 1374, 1366, 3, 2, 2, 2, 1374, 1375, 3, 2, 2, 2, 1375,
	1376, 3, 2, 2, 2, 1376, 1449, 7, 10, 2, 2, 1377, 1449, 5, 144, 73, 2, 1378,
	1449, 7, 43, 2, 2, 1379, 1383, 7, 45, 2, 2, 1380, 1381, 7, 4, 2, 2, 1381,
	1382, 7, 222, 2, 2, 1382, 1384, 7, 5, 2, 2, 1383, 1380, 3, 2, 2, 2, 1383,
	1384, 3, 2, 2, 2, 1384, 1449, 3, 2, 2, 2, 1385, 1389, 7, 46, 2, 2, 1386,
	1387, 7, 4, 2, 2, 1387, 1388, 7, 222, 2, 2, 1388, 1390, 7, 5, 2, 2, 1389,
	1386, 3, 2, 2, 2, 1389, 1390, 3, 2, 2, 2, 1390, 1449, 3, 2, 2, 2, 1391,
	1395, 7, 108, 2, 2, 1392, 1393, 7, 4, 2, 2, 1393, 1394, 7, 222, 2, 2, 1394,
	1396, 7, 5, 2, 2, 1395, 1392, 3, 2, 2, 2, 1395, 1396, 3, 2, 2, 2, 1396,
	1449, 3, 2, 2, 2, 1397, 1401, 7, 109, 2, 2, 1398, 1399, 7, 4, 2, 2, 1399,
	1400, 7, 222, 2, 2, 1400, 1402, 7, 5, 2, 2, 1401, 1398, 3, 2, 2, 2, 1401,
	1402, 3, 2, 2, 2, 1402, 1449, 3, 2, 2, 2, 1403, 1449, 7, 47, 2, 2, 1404,
	1405, 7, 174, 2, 2, 1405, 1406, 7, 4, 2, 2, 1406, 1407, 5, 88, 45, 2, 1407,
	1408, 7, 74, 2, 2, 1408, 1411, 5, 88, 45, 2, 1409, 1410, 7, 72, 2, 2, 1410,
	1412, 5, 88, 45, 2, 1411, 1409, 3, 2, 2, 2, 1411, 1412, 3, 2, 2, 2, 1412,
	1413, 3, 2, 2, 2, 1413, 1414, 7, 5, 2, 2, 1414, 1449, 3, 2, 2, 2, 1415,
	1416, 7, 121, 2, 2, 1416, 1417, 7, 4, 2, 2, 1417, 1420, 5, 88, 45, 2, 1418,
	1419, 7, 6, 2, 2, 1419, 1421, 5, 106, 54, 2, 1420, 1418, 3, 2, 2, 2, 1420,
	1421, 3, 2, 2, 2, 1421, 1422, 3, 2, 2, 2, 1422, 1423, 7, 5, 2, 2, 1423,
	1449, 3, 2, 2, 2, 1424, 1425, 7, 67, 2, 2, 1425, 1426, 7, 4, 2, 2, 1426,
	1427, 5, 144, 73, 2, 1427, 1428, 7, 74, 2, 2, 1428, 1429, 5, 88, 45, 2,
	1429, 1430, 7, 5, 2, 2, 1430, 1449, 3, 2, 2, 2, 1431, 1432, 7, 4, 2, 2,
	1432, 1433, 5, 82, 42, 2, 1433, 1434, 7, 5, 2, 2, 1434, 1449, 3, 2, 2,
	2, 1435, 1436, 7, 83, 2, 2, 1436, 1445, 7, 4, 2, 2, 1437, 1442, 5, 136,
	69, 2, 1438, 1439, 7, 6, 2, 2, 1439, 1441, 5, 136, 69, 2, 1440, 1438, 3,
	2, 2, 2, 1441, 1444, 3, 2, 2, 2, 1442, 1440, 3, 2, 2, 2, 1442, 1443, 3,
	2, 2, 2, 1443, 1446, 3, 2, 2, 2, 1444, 1442, 3, 2, 2, 2, 1445, 1437, 3,
	2, 2, 2, 1445, 1446, 3, 2, 2, 2, 1446, 1447, 3, 2, 2, 2, 1447, 1449, 7,
	5, 2, 2, 1448, 1209, 3, 2, 2, 2, 1448, 1211, 3, 2, 2, 2, 1448, 1212, 3,
	2, 2, 2, 1448, 1215, 3, 2, 2, 2, 1448, 1217, 3, 2, 2, 2, 1448, 1218, 3,
	2, 2, 2, 1448, 1219, 3, 2, 2, 2, 1448, 1220, 3, 2, 2, 2, 1448, 1221, 3,
	2, 2, 2, 1448, 1222, 3, 2, 2, 2, 1448, 1229, 3, 2, 2, 2, 1448, 1239, 3,
	2, 2, 2, 1448, 1251, 3, 2, 2, 2, 1448, 1261, 3, 2, 2, 2, 1448, 1298, 3,
	2, 2, 2, 1448, 1302, 3, 2, 2, 2, 1448, 1316, 3, 2, 2, 2, 1448, 1320, 3,
	2, 2, 2, 1448, 1325, 3, 2, 2, 2, 1448, 1338, 3, 2, 2, 2, 1448, 1350, 3,
	2, 2, 2, 1448, 1357, 3, 2, 2, 2, 1448, 1364, 3, 2, 2, 2, 1448, 1377, 3,
	2, 2, 2, 1448, 1378, 3, 2, 2, 2, 1448, 1379, 3, 2, 2, 2, 1448, 1385, 3,
	2, 2, 2, 1448, 1391, 3, 2, 2, 2, 1448, 1397, 3, 2, 2, 2, 1448, 1403, 3,
	2, 2, 2, 1448, 1404, 3, 2, 2, 2, 1448, 1415, 3, 2, 2, 2, 1448, 1424, 3,
	2, 2, 2, 1448, 1431, 3, 2, 2, 2, 1448, 1435, 3, 2, 2, 2, 1449, 1460, 3,
	2, 2, 2, 1450, 1451, 12, 16, 2, 2, 1451, 1452, 7, 9, 2, 2, 1452, 1453,
	5, 88, 45, 2, 1453, 1454, 7, 10, 2, 2, 1454, 1459, 3, 2, 2, 2, 1455, 1456,
	12, 14, 2, 2, 1456, 1457, 7, 3, 2, 2, 1457, 1459, 5, 144, 73, 2, 1458,
	1450, 3, 2, 2, 2, 1458, 1455, 3, 2, 2, 2, 1459, 1462, 3, 2, 2, 2, 1460,
	1458, 3, 2, 2, 2, 1460, 1461, 3, 2, 2, 2, 1461, 91, 3, 2, 2, 2, 1462, 1460,
	3, 2, 2, 2, 1463, 1464, 7, 87, 2, 2, 1464, 1468, 7, 125, 2, 2, 1465, 1466,
	7, 149, 2, 2, 1466, 1468, 7, 125, 2, 2, 1467, 1463, 3, 2, 2, 2, 1467, 1465,
	3, 2, 2, 2, 1468, 93, 3, 2, 2, 2, 1469, 1470, 7, 181, 2, 2, 1470, 1471,
	7, 206, 2, 2, 1471, 1476, 5, 102, 52, 2, 1472, 1473, 7, 181, 2, 2, 1473,
	1474, 7, 206, 2, 2, 1474, 1476, 7, 12, 2, 2, 1475, 1469, 3, 2, 2, 2, 1475,
	1472, 3, 2, 2, 2, 1476, 95, 3, 2, 2, 2, 1477, 1478, 9, 13, 2, 2, 1478,
	97, 3, 2, 2, 2, 1479, 1480, 9, 14, 2, 2, 1480, 99, 3, 2, 2, 2, 1481, 1482,
	9, 15, 2, 2, 1482, 101, 3, 2, 2, 2, 1483, 1485, 7, 94, 2, 2, 1484, 1486,
	9, 11, 2, 2, 1485, 1484, 3, 2, 2, 2, 1485, 1486, 3, 2, 2, 2, 1486, 1487,
	3, 2, 2, 2, 1487, 1488, 7, 12, 2, 2, 1488, 1491, 5, 104, 53, 2, 1489, 1490,
	7, 183, 2, 2, 1490, 1492, 5, 104, 53, 2, 1491, 1489, 3, 2, 2, 2, 1491,
	1492, 3, 2, 2, 2, 1492, 103, 3, 2, 2, 2, 1493, 1494, 9, 16, 2, 2, 1494,
	105, 3, 2, 2, 2, 1495, 1496, 9, 17, 2, 2, 1496, 107, 3, 2, 2, 2, 1497,
	1506, 7, 4, 2, 2, 1498, 1503, 5, 110, 56, 2, 1499, 1500, 7, 6, 2, 2, 1500,
	1502, 5, 110, 56, 2, 1501, 1499, 3, 2, 2, 2, 1502, 1505, 3, 2, 2, 2, 1503,
	1501, 3, 2, 2, 2, 1503, 1504, 3, 2, 2, 2, 1504, 1507, 3, 2, 2, 2, 1505,
	1503, 3, 2, 2, 2, 1506, 1498, 3, 2, 2, 2, 1506, 1507, 3, 2, 2, 2, 1507,
	1508, 3, 2, 2, 2, 1508, 1509, 7, 5, 2, 2, 1509, 109, 3, 2, 2, 2, 1510,
	1511, 8, 56, 1, 2, 1511, 1512, 7, 20, 2, 2, 1512, 1513, 7, 209, 2, 2, 1513,
	1514, 5, 110, 56, 2, 1514, 1515, 7, 211, 2, 2, 1515, 1558, 3, 2, 2, 2,
	1516, 1517, 7, 111, 2, 2, 1517, 1518, 7, 209, 2, 2, 1518, 1519, 5, 110,
	56, 2, 1519, 1520, 7, 6, 2, 2, 1520, 1521, 5, 110, 56, 2, 1521, 1522, 7,
	211, 2, 2, 1522, 1558, 3, 2, 2, 2, 1523, 1524, 7, 159, 2, 2, 1524, 1525,
	7, 4, 2, 2, 1525, 1526, 5, 144, 73, 2, 1526, 1533, 5, 110, 56, 2, 1527,
	1528, 7, 6, 2, 2, 1528, 1529, 5, 144, 73, 2, 1529, 1530, 5, 110, 56, 2,
	1530, 1532, 3, 2, 2, 2, 1531, 1527, 3, 2, 2, 2, 1532, 1535, 3, 2, 2, 2,
	1533, 1531, 3, 2, 2, 2, 1533, 1534, 3, 2, 2, 2, 1534, 1536, 3, 2, 2, 2,
	1535, 1533, 3, 2, 2, 2, 1536, 1537, 7, 5, 2, 2, 1537, 1558, 3, 2, 2, 2,
	1538, 1550, 5, 114, 58, 2, 1539, 1540, 7, 4, 2, 2, 1540, 1545, 5, 112,
	57, 2, 1541, 1542, 7, 6, 2, 2, 1542, 1544, 5, 112, 57, 2, 1543, 1541, 3,
	2, 2, 2, 1544, 1547, 3, 2, 2, 2, 1545, 1543, 3, 2, 2, 2, 1545, 1546, 3,
	2, 2, 2, 1546, 1548, 3, 2, 2, 2, 1547, 1545, 3, 2, 2, 2, 1548, 1549, 7,
	5, 2, 2, 1549, 1551, 3, 2, 2, 2, 1550, 1539, 3, 2, 2, 2, 1550, 1551, 3,
	2, 2, 2, 1551, 1558, 3, 2, 2, 2, 1552, 1553, 7, 94, 2, 2, 1553, 1554, 5,
	104, 53, 2, 1554, 1555, 7, 183, 2, 2, 1555, 1556, 5, 104, 53, 2, 1556,
	1558, 3, 2, 2, 2, 1557, 1510, 3, 2, 2, 2, 1557, 1516, 3, 2, 2, 2, 1557,
	1523, 3, 2, 2, 2, 1557, 1538, 3, 2, 2, 2, 1557, 1552, 3, 2, 2, 2, 1558,
	1563, 3, 2, 2, 2, 1559, 1560, 12, 8, 2, 2, 1560, 1562, 7, 20, 2, 2, 1561,
	1559, 3, 2, 2, 2, 1562, 1565, 3, 2, 2, 2, 1563, 1561, 3, 2, 2, 2, 1563,
	1564, 3, 2, 2, 2, 1564, 111, 3, 2, 2, 2, 1565, 1563, 3, 2, 2, 2, 1566,
	1569, 7, 222, 2, 2, 1567, 1569, 5, 110, 56, 2, 1568, 1566, 3, 2, 2, 2,
	1568, 1567, 3, 2, 2, 2, 1569, 113, 3, 2, 2, 2, 1570, 1575, 7, 229, 2, 2,
	1571, 1575, 7, 230, 2, 2, 1572, 1575, 7, 231, 2, 2, 1573, 1575, 5, 144,
	73, 2, 1574, 1570, 3, 2, 2, 2, 1574, 1571, 3, 2, 2, 2, 1574, 1572, 3, 2,
	2, 2, 1574, 1573, 3, 2, 2, 2, 1575, 115, 3, 2, 2, 2, 1576, 1577, 7, 200,
	2, 2, 1577, 1578, 5, 82, 42, 2, 1578, 1579, 7, 180, 2, 2, 1579, 1580, 5,
	82, 42, 2, 1580, 117, 3, 2, 2, 2, 1581, 1582, 7, 69, 2, 2, 1582, 1583,
	7, 4, 2, 2, 1583, 1584, 7, 201, 2, 2, 1584, 1585, 5, 84, 43, 2, 1585, 1586,
	7, 5, 2, 2, 1586, 119, 3, 2, 2, 2, 1587, 1588, 7, 134, 2, 2, 1588, 1599,
	7, 4, 2, 2, 1589, 1590, 7, 135, 2, 2, 1590, 1591, 7, 26, 2, 2, 1591, 1596,
	5, 82, 42, 2, 1592, 1593, 7, 6, 2, 2, 1593, 1595, 5, 82, 42, 2, 1594, 1592,
	3, 2, 2, 2, 1595, 1598, 3, 2, 2, 2, 1596, 1594, 3, 2, 2, 2, 1596, 1597,
	3, 2, 2, 2, 1597, 1600, 3, 2, 2, 2, 1598, 1596, 3, 2, 2, 2, 1599, 1589,
	3, 2, 2, 2, 1599, 1600, 3, 2, 2, 2, 1600, 1611, 3, 2, 2, 2, 1601, 1602,
	7, 130, 2, 2, 1602, 1603, 7, 26, 2, 2, 1603, 1608, 5, 50, 26, 2, 1604,
	1605, 7, 6, 2, 2, 1605, 1607, 5, 50, 26, 2, 1606, 1604, 3, 2, 2, 2, 1607,
	1610, 3, 2, 2, 2, 1608, 1606, 3, 2, 2, 2, 1608, 1609, 3, 2, 2, 2, 1609,
	1612, 3, 2, 2, 2, 1610, 1608, 3, 2, 2, 2, 1611, 1601, 3, 2, 2, 2, 1611,
	1612, 3, 2, 2, 2, 1612, 1614, 3, 2, 2, 2, 1613, 1615, 5, 122, 62, 2, 1614,
	1613, 3, 2, 2, 2, 1614, 1615, 3, 2, 2, 2, 1615, 1616, 3, 2, 2, 2, 1616,
	1617, 7, 5, 2, 2, 1617, 121, 3, 2, 2, 2, 1618, 1619, 7, 142, 2, 2, 1619,
	1635, 5, 124, 63, 2, 1620, 1621, 7, 160, 2, 2, 1621, 1635, 5, 124, 63,
	2, 1622, 1623, 7, 142, 2, 2, 1623, 1624, 7, 25, 2, 2, 1624, 1625, 5, 124,
	63, 2, 1625, 1626, 7, 18, 2, 2, 1626, 1627, 5, 124, 63, 2, 1627, 1635,
	3, 2, 2, 2, 1628, 1629, 7, 160, 2, 2, 1629, 1630, 7, 25, 2, 2, 1630, 1631,
	5, 124, 63, 2, 1631, 1632, 7, 18, 2, 2, 1632, 1633, 5, 124, 63, 2, 1633,
	1635, 3, 2, 2, 2, 1634, 1618, 3, 2, 2, 2, 1634, 1620, 3, 2, 2, 2, 1634,
	1622, 3, 2, 2, 2, 1634, 1628, 3, 2, 2, 2, 1635, 123, 3, 2, 2, 2, 1636,
	1637, 7, 189, 2, 2, 1637, 1646, 7, 138, 2, 2, 1638, 1639, 7, 189, 2, 2,
	1639, 1646, 7, 71, 2, 2, 1640, 1641, 7, 42, 2, 2, 1641, 1646, 7, 159, 2,
	2, 1642, 1643, 5, 82, 42, 2, 1643, 1644, 9, 18, 2, 2, 1644, 1646, 3, 2,
	2, 2, 1645, 1636, 3, 2, 2, 2, 1645, 1638, 3, 2, 2, 2, 1645, 1640, 3, 2,
	2, 2, 1645, 1642, 3, 2, 2, 2, 1646, 125, 3, 2, 2, 2, 1647, 1648, 7, 73,
	2, 2, 1648, 1652, 9, 19, 2, 2, 1649, 1650, 7, 187, 2, 2, 1650, 1652, 9,
	20, 2, 2, 1651, 1647, 3, 2, 2, 2, 1651, 1649, 3, 2, 2, 2, 1652, 127, 3,
	2, 2, 2, 1653, 1654, 7, 98, 2, 2, 1654, 1655, 7, 105, 2, 2, 1655, 1659,
	5, 130, 66, 2, 1656, 1657, 7, 143, 2, 2, 1657, 1659, 9, 21, 2, 2, 1658,
	1653, 3, 2, 2, 2, 1658, 1656, 3, 2, 2, 2, 1659, 129, 3, 2, 2, 2, 1660,
	1661, 7, 143, 2, 2, 1661, 1668, 7, 190, 2, 2, 1662, 1663, 7, 143, 2, 2,
	1663, 1668, 7, 37, 2, 2, 1664, 1665, 7, 146, 2, 2, 1665, 1668, 7, 143,
	2, 2, 1666, 1668, 7, 165, 2, 2, 1667, 1660, 3, 2, 2, 2, 1667, 1662, 3,
	2, 2, 2, 1667, 1664, 3, 2, 2, 2, 1667, 1666, 3, 2, 2, 2, 1668, 131, 3,
	2, 2, 2, 1669, 1675, 5, 82, 42, 2, 1670, 1671, 5, 144, 73, 2, 1671, 1672,
	7, 11, 2, 2, 1672, 1673, 5, 82, 42, 2, 1673, 1675, 3, 2, 2, 2, 1674, 1669,
	3, 2, 2, 2, 1674, 1670, 3, 2, 2, 2, 1675, 133, 3, 2, 2, 2, 1676, 1681,
	7, 164, 2, 2, 1677, 1681, 7, 52, 2, 2, 1678, 1681, 7, 92, 2, 2, 1679, 1681,
	5, 144, 73, 2, 1680, 1676, 3, 2, 2, 2, 1680, 1677, 3, 2, 2, 2, 1680, 1678,
	3, 2, 2, 2, 1680, 1679, 3, 2, 2, 2, 1681, 135, 3, 2, 2, 2, 1682, 1687,
	5, 144, 73, 2, 1683, 1684, 7, 3, 2, 2, 1684, 1686, 5, 144, 73, 2, 1685,
	1683, 3, 2, 2, 2, 1686, 1689, 3, 2, 2, 2, 1687, 1685, 3, 2, 2, 2, 1687,
	1688, 3, 2, 2, 2, 1688, 137, 3, 2, 2, 2, 1689, 1687, 3, 2, 2, 2, 1690,
	1694, 7, 47, 2, 2, 1691, 1694, 7, 44, 2, 2, 1692, 1694, 5, 140, 71, 2,
	1693, 1690, 3, 2, 2, 2, 1693, 1691, 3, 2, 2, 2, 1693, 1692, 3, 2, 2, 2,
	1694, 139, 3, 2, 2, 2, 1695, 1696, 7, 194, 2, 2, 1696, 1701, 5, 144, 73,
	2, 1697, 1698, 7, 155, 2, 2, 1698, 1701, 5, 144, 73, 2, 1699, 1701, 5,
	144, 73, 2, 1700, 1695, 3, 2, 2, 2, 1700, 1697, 3, 2, 2, 2, 1700, 1699,
	3, 2, 2, 2, 1701, 141, 3, 2, 2, 2, 1702, 1707, 5, 144, 73, 2, 1703, 1704,
	7, 6, 2, 2, 1704, 1706, 5, 144, 73, 2, 1705, 1703, 3, 2, 2, 2, 1706, 1709,
	3, 2, 2, 2, 1707, 1705, 3, 2, 2, 2, 1707, 1708, 3, 2, 2, 2, 1708, 143,
	3, 2, 2, 2, 1709, 1707, 3, 2, 2, 2, 1710, 1716, 7, 225, 2, 2, 1711, 1716,
	7, 227, 2, 2, 1712, 1716, 5, 148, 75, 2, 1713, 1716, 7, 228, 2, 2, 1714,
	1716, 7, 226, 2, 2, 1715, 1710, 3, 2, 2, 2, 1715, 1711, 3, 2, 2, 2, 1715,
	1712, 3, 2, 2, 2, 1715, 1713, 3, 2, 2, 2, 1715, 1714, 3, 2, 2, 2, 1716,
	145, 3, 2, 2, 2, 1717, 1721, 7, 223, 2, 2, 1718, 1721, 7, 224, 2, 2, 1719,
	1721, 7, 222, 2, 2, 1720, 1717, 3, 2, 2, 2, 1720, 1718, 3, 2, 2, 2, 1720,
	1719, 3, 2, 2, 2, 1721, 147, 3, 2, 2, 2, 1722, 1723, 9, 22, 2, 2, 1723,
	149, 3, 2, 2, 2, 216, 172, 177, 183, 187, 201, 205, 209, 213, 221, 225,
	228, 235, 244, 250, 254, 260, 267, 276, 312, 317, 328, 334, 344, 347, 354,
	363, 371, 375, 385, 388, 398, 411, 417, 422, 428, 437, 443, 450, 458, 463,
	467, 475, 481, 488, 493, 497, 507, 510, 514, 517, 525, 530, 546, 552, 558,
	560, 566, 572, 574, 580, 599, 604, 611, 623, 625, 645, 648, 652, 656, 674,
	677, 685, 688, 694, 701, 706, 712, 716, 720, 726, 734, 749, 756, 761, 776,
	787, 797, 800, 804, 812, 818, 821, 823, 835, 842, 846, 850, 854, 861, 870,
	873, 877, 882, 886, 889, 896, 907, 910, 920, 923, 934, 939, 947, 950, 954,
	958, 969, 972, 979, 998, 1002, 1006, 1010, 1014, 1018, 1020, 1031, 1036,
	1045, 1051, 1055, 1057, 1065, 1082, 1088, 1099, 1106, 1110, 1118, 1120,
	1133, 1141, 1150, 1156, 1164, 1170, 1174, 1179, 1184, 1190, 1204, 1206,
	1235, 1246, 1256, 1259, 1264, 1271, 1274, 1283, 1286, 1290, 1293, 1296,
	1308, 1311, 1330, 1334, 1342, 1346, 1371, 1374, 1383, 1389, 1395, 1401,
	1411, 1420, 1442, 1445, 1448, 1458, 1460, 1467, 1475, 1485, 1491, 1503,
	1506, 1533, 1545, 1550, 1557, 1563, 1568, 1574, 1596, 1599, 1608, 1611,
	1614, 1634, 1645, 1651, 1658, 1667, 1674, 1680, 1687, 1693, 1700, 1707,
	1715, 1720,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'.'", "'('", "')'", "','", "'?'", "'->'", "'['", "']'", "'=>'", "",
	"'ADD'", "'ADMIN'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANY'",
	"'ARRAY'", "'AS'", "'ASC'", "'AT'", "'BERNOULLI'", "'BETWEEN'", "'BY'",
	"'CALL'", "'CALLED'", "'CASCADE'", "'CASE'", "'CAST'", "'CATALOGS'", "'COLUMN'",
	"'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'CONSTRAINT'", "'CREATE'",
	"'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_ROLE'", "'CURRENT_TIME'",
	"'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATE'", "'DAY'", "'DEALLOCATE'",
	"'DELETE'", "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DISTINCT'", "'DISTRIBUTED'",
	"'DROP'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUDING'", "'EXECUTE'",
	"'EXISTS'", "'EXPLAIN'", "'EXTRACT'", "'FALSE'", "'FILTER'", "'FIRST'",
	"'FOLLOWING'", "'FOR'", "'FORMAT'", "'FROM'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'",
	"'GRANT'", "'GRANTED'", "'GRANTS'", "'GRAPHVIZ'", "'GROUP'", "'GROUPING'",
	"'HAVING'", "'HOUR'", "'IF'", "'IGNORE'", "'IN'", "'INCLUDING'", "'INNER'",
	"'INPUT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'IO'", "'IS'",
	"'ISOLATION'", "'JSON'", "'JOIN'", "'LANGUAGE'", "'LAST'", "'LATERAL'",
	"'LEFT'", "'LEVEL'", "'LIKE'", "'LIMIT'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
	"'LOGICAL'", "'MAP'", "'MINUTE'", "'MONTH'", "'NATURAL'", "'NFC'", "'NFD'",
	"'NFKC'", "'NFKD'", "'NO'", "'NONE'", "'NORMALIZE'", "'NOT'", "'NULL'",
	"'NULLIF'", "'NULLS'", "'ON'", "'ONLY'", "'OPTION'", "'OR'", "'ORDER'",
	"'ORDINALITY'", "'OUTER'", "'OUTPUT'", "'OVER'", "'PARTITION'", "'PARTITIONS'",
	"'POSITION'", "'PRECEDING'", "'PREPARE'", "'PRIVILEGES'", "'PROPERTIES'",
	"'RANGE'", "'READ'", "'RECURSIVE'", "'RENAME'", "'REPEATABLE'", "'REPLACE'",
	"'RESET'", "'RESPECT'", "'RESTRICT'", "'RETURN'", "'RETURNS'", "'REVOKE'",
	"'RIGHT'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'",
	"'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SELECT'", "'SERIALIZABLE'", "'SESSION'",
	"'SET'", "'SETS'", "'SHOW'", "'SOME'", "'SQL'", "'START'", "'STATS'", "'SUBSTRING'",
	"'SYSTEM'", "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TEXT'", "'THEN'",
	"'TIME'", "'TIMESTAMP'", "'TO'", "'TRANSACTION'", "'TRUE'", "'TRY_CAST'",
	"'TYPE'", "'UESCAPE'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNNEST'",
	"'USE'", "'USER'", "'USING'", "'VALIDATE'", "'VALUES'", "'VERBOSE'", "'VIEW'",
	"'WHEN'", "'WHERE'", "'WITH'", "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'",
	"'='", "", "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'",
	"'||'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "MyString", "ADD", "ADMIN", "ALL",
	"ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BERNOULLI",
	"BETWEEN", "BY", "CALL", "CALLED", "CASCADE", "CASE", "CAST", "CATALOGS",
	"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONSTRAINT", "CREATE",
	"CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME",
	"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATE", "DAY", "DEALLOCATE",
	"DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DISTINCT", "DISTRIBUTED",
	"DROP", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS",
	"EXPLAIN", "EXTRACT", "FALSE", "FILTER", "FIRST", "FOLLOWING", "FOR", "FORMAT",
	"FROM", "FULL", "FUNCTION", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS",
	"GRAPHVIZ", "GROUP", "GROUPING", "HAVING", "HOUR", "IF", "IGNORE", "IN",
	"INCLUDING", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL", "INTO",
	"IO", "IS", "ISOLATION", "JSON", "JOIN", "LANGUAGE", "LAST", "LATERAL",
	"LEFT", "LEVEL", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LOGICAL",
	"MAP", "MINUTE", "MONTH", "NATURAL", "NFC", "NFD", "NFKC", "NFKD", "NO",
	"NONE", "NORMALIZE", "NOT", "NULL", "NULLIF", "NULLS", "ON", "ONLY", "OPTION",
	"OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "PARTITION", "PARTITIONS",
	"POSITION", "PRECEDING", "PREPARE", "PRIVILEGES", "PROPERTIES", "RANGE",
	"READ", "RECURSIVE", "RENAME", "REPEATABLE", "REPLACE", "RESET", "RESPECT",
	"RESTRICT", "RETURN", "RETURNS", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK",
	"ROLLUP", "ROW", "ROWS", "SCHEMA", "SCHEMAS", "SECOND", "SELECT", "SERIALIZABLE",
	"SESSION", "SET", "SETS", "SHOW", "SOME", "SQL", "START", "STATS", "SUBSTRING",
	"SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIME", "TIMESTAMP",
	"TO", "TRANSACTION", "TRUE", "TRY_CAST", "TYPE", "UESCAPE", "UNBOUNDED",
	"UNCOMMITTED", "UNION", "UNNEST", "USE", "USER", "USING", "VALIDATE", "VALUES",
	"VERBOSE", "VIEW", "WHEN", "WHERE", "WITH", "WORK", "WRITE", "YEAR", "ZONE",
	"EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH",
	"PERCENT", "CONCAT", "STRING", "UNICODE_STRING", "BINARY_LITERAL", "INTEGER_VALUE",
	"DECIMAL_VALUE", "DOUBLE_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER",
	"BACKQUOTED_IDENTIFIER", "TIME_WITH_TIME_ZONE", "TIMESTAMP_WITH_TIME_ZONE",
	"DOUBLE_PRECISION", "SIMPLE_COMMENT", "BRACKETED_COMMENT", "WS", "UNRECOGNIZED",
	"DELIMITER",
}

var ruleNames = []string{
	"singleStatement", "standaloneExpression", "standaloneRoutineBody", "statement",
	"query", "with", "tableElement", "columnDefinition", "likeClause", "properties",
	"property", "sqlParameterDeclaration", "routineCharacteristics", "routineCharacteristic",
	"alterRoutineCharacteristics", "alterRoutineCharacteristic", "routineBody",
	"returnStatement", "language", "determinism", "nullCallClause", "queryNoWith",
	"queryTerm", "queryPrimary", "sortItem", "querySpecification", "groupBy",
	"groupingElement", "groupingSet", "namedQuery", "setQuantifier", "selectItem",
	"relation", "joinType", "joinCriteria", "sampledRelation", "sampleType",
	"aliasedRelation", "columnAliases", "relationPrimary", "expression", "booleanExpression",
	"predicate", "valueExpression", "primaryExpression", "nullTreatment", "timeZoneSpecifier",
	"comparisonOperator", "comparisonQuantifier", "booleanValue", "interval",
	"intervalField", "normalForm", "types", "type_r", "typeParameter", "baseType",
	"whenClause", "filter", "over", "windowFrame", "frameBound", "explainOption",
	"transactionMode", "levelOfIsolation", "callArgument", "privilege", "qualifiedName",
	"grantor", "principal", "roles", "identifier", "number", "nonReserved",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type SqlBase4GoParser struct {
	*antlr.BaseParser
}

func NewSqlBase4GoParser(input antlr.TokenStream) *SqlBase4GoParser {
	this := new(SqlBase4GoParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SqlBase4Go.g4"

	return this
}

// SqlBase4GoParser tokens.
const (
	SqlBase4GoParserEOF                      = antlr.TokenEOF
	SqlBase4GoParserT__0                     = 1
	SqlBase4GoParserT__1                     = 2
	SqlBase4GoParserT__2                     = 3
	SqlBase4GoParserT__3                     = 4
	SqlBase4GoParserT__4                     = 5
	SqlBase4GoParserT__5                     = 6
	SqlBase4GoParserT__6                     = 7
	SqlBase4GoParserT__7                     = 8
	SqlBase4GoParserT__8                     = 9
	SqlBase4GoParserMyString                 = 10
	SqlBase4GoParserADD                      = 11
	SqlBase4GoParserADMIN                    = 12
	SqlBase4GoParserALL                      = 13
	SqlBase4GoParserALTER                    = 14
	SqlBase4GoParserANALYZE                  = 15
	SqlBase4GoParserAND                      = 16
	SqlBase4GoParserANY                      = 17
	SqlBase4GoParserARRAY                    = 18
	SqlBase4GoParserAS                       = 19
	SqlBase4GoParserASC                      = 20
	SqlBase4GoParserAT                       = 21
	SqlBase4GoParserBERNOULLI                = 22
	SqlBase4GoParserBETWEEN                  = 23
	SqlBase4GoParserBY                       = 24
	SqlBase4GoParserCALL                     = 25
	SqlBase4GoParserCALLED                   = 26
	SqlBase4GoParserCASCADE                  = 27
	SqlBase4GoParserCASE                     = 28
	SqlBase4GoParserCAST                     = 29
	SqlBase4GoParserCATALOGS                 = 30
	SqlBase4GoParserCOLUMN                   = 31
	SqlBase4GoParserCOLUMNS                  = 32
	SqlBase4GoParserCOMMENT                  = 33
	SqlBase4GoParserCOMMIT                   = 34
	SqlBase4GoParserCOMMITTED                = 35
	SqlBase4GoParserCONSTRAINT               = 36
	SqlBase4GoParserCREATE                   = 37
	SqlBase4GoParserCROSS                    = 38
	SqlBase4GoParserCUBE                     = 39
	SqlBase4GoParserCURRENT                  = 40
	SqlBase4GoParserCURRENT_DATE             = 41
	SqlBase4GoParserCURRENT_ROLE             = 42
	SqlBase4GoParserCURRENT_TIME             = 43
	SqlBase4GoParserCURRENT_TIMESTAMP        = 44
	SqlBase4GoParserCURRENT_USER             = 45
	SqlBase4GoParserDATA                     = 46
	SqlBase4GoParserDATE                     = 47
	SqlBase4GoParserDAY                      = 48
	SqlBase4GoParserDEALLOCATE               = 49
	SqlBase4GoParserDELETE                   = 50
	SqlBase4GoParserDESC                     = 51
	SqlBase4GoParserDESCRIBE                 = 52
	SqlBase4GoParserDETERMINISTIC            = 53
	SqlBase4GoParserDISTINCT                 = 54
	SqlBase4GoParserDISTRIBUTED              = 55
	SqlBase4GoParserDROP                     = 56
	SqlBase4GoParserELSE                     = 57
	SqlBase4GoParserEND                      = 58
	SqlBase4GoParserESCAPE                   = 59
	SqlBase4GoParserEXCEPT                   = 60
	SqlBase4GoParserEXCLUDING                = 61
	SqlBase4GoParserEXECUTE                  = 62
	SqlBase4GoParserEXISTS                   = 63
	SqlBase4GoParserEXPLAIN                  = 64
	SqlBase4GoParserEXTRACT                  = 65
	SqlBase4GoParserFALSE                    = 66
	SqlBase4GoParserFILTER                   = 67
	SqlBase4GoParserFIRST                    = 68
	SqlBase4GoParserFOLLOWING                = 69
	SqlBase4GoParserFOR                      = 70
	SqlBase4GoParserFORMAT                   = 71
	SqlBase4GoParserFROM                     = 72
	SqlBase4GoParserFULL                     = 73
	SqlBase4GoParserFUNCTION                 = 74
	SqlBase4GoParserFUNCTIONS                = 75
	SqlBase4GoParserGRANT                    = 76
	SqlBase4GoParserGRANTED                  = 77
	SqlBase4GoParserGRANTS                   = 78
	SqlBase4GoParserGRAPHVIZ                 = 79
	SqlBase4GoParserGROUP                    = 80
	SqlBase4GoParserGROUPING                 = 81
	SqlBase4GoParserHAVING                   = 82
	SqlBase4GoParserHOUR                     = 83
	SqlBase4GoParserIF                       = 84
	SqlBase4GoParserIGNORE                   = 85
	SqlBase4GoParserIN                       = 86
	SqlBase4GoParserINCLUDING                = 87
	SqlBase4GoParserINNER                    = 88
	SqlBase4GoParserINPUT                    = 89
	SqlBase4GoParserINSERT                   = 90
	SqlBase4GoParserINTERSECT                = 91
	SqlBase4GoParserINTERVAL                 = 92
	SqlBase4GoParserINTO                     = 93
	SqlBase4GoParserIO                       = 94
	SqlBase4GoParserIS                       = 95
	SqlBase4GoParserISOLATION                = 96
	SqlBase4GoParserJSON                     = 97
	SqlBase4GoParserJOIN                     = 98
	SqlBase4GoParserLANGUAGE                 = 99
	SqlBase4GoParserLAST                     = 100
	SqlBase4GoParserLATERAL                  = 101
	SqlBase4GoParserLEFT                     = 102
	SqlBase4GoParserLEVEL                    = 103
	SqlBase4GoParserLIKE                     = 104
	SqlBase4GoParserLIMIT                    = 105
	SqlBase4GoParserLOCALTIME                = 106
	SqlBase4GoParserLOCALTIMESTAMP           = 107
	SqlBase4GoParserLOGICAL                  = 108
	SqlBase4GoParserMAP                      = 109
	SqlBase4GoParserMINUTE                   = 110
	SqlBase4GoParserMONTH                    = 111
	SqlBase4GoParserNATURAL                  = 112
	SqlBase4GoParserNFC                      = 113
	SqlBase4GoParserNFD                      = 114
	SqlBase4GoParserNFKC                     = 115
	SqlBase4GoParserNFKD                     = 116
	SqlBase4GoParserNO                       = 117
	SqlBase4GoParserNONE                     = 118
	SqlBase4GoParserNORMALIZE                = 119
	SqlBase4GoParserNOT                      = 120
	SqlBase4GoParserNULL                     = 121
	SqlBase4GoParserNULLIF                   = 122
	SqlBase4GoParserNULLS                    = 123
	SqlBase4GoParserON                       = 124
	SqlBase4GoParserONLY                     = 125
	SqlBase4GoParserOPTION                   = 126
	SqlBase4GoParserOR                       = 127
	SqlBase4GoParserORDER                    = 128
	SqlBase4GoParserORDINALITY               = 129
	SqlBase4GoParserOUTER                    = 130
	SqlBase4GoParserOUTPUT                   = 131
	SqlBase4GoParserOVER                     = 132
	SqlBase4GoParserPARTITION                = 133
	SqlBase4GoParserPARTITIONS               = 134
	SqlBase4GoParserPOSITION                 = 135
	SqlBase4GoParserPRECEDING                = 136
	SqlBase4GoParserPREPARE                  = 137
	SqlBase4GoParserPRIVILEGES               = 138
	SqlBase4GoParserPROPERTIES               = 139
	SqlBase4GoParserRANGE                    = 140
	SqlBase4GoParserREAD                     = 141
	SqlBase4GoParserRECURSIVE                = 142
	SqlBase4GoParserRENAME                   = 143
	SqlBase4GoParserREPEATABLE               = 144
	SqlBase4GoParserREPLACE                  = 145
	SqlBase4GoParserRESET                    = 146
	SqlBase4GoParserRESPECT                  = 147
	SqlBase4GoParserRESTRICT                 = 148
	SqlBase4GoParserRETURN                   = 149
	SqlBase4GoParserRETURNS                  = 150
	SqlBase4GoParserREVOKE                   = 151
	SqlBase4GoParserRIGHT                    = 152
	SqlBase4GoParserROLE                     = 153
	SqlBase4GoParserROLES                    = 154
	SqlBase4GoParserROLLBACK                 = 155
	SqlBase4GoParserROLLUP                   = 156
	SqlBase4GoParserROW                      = 157
	SqlBase4GoParserROWS                     = 158
	SqlBase4GoParserSCHEMA                   = 159
	SqlBase4GoParserSCHEMAS                  = 160
	SqlBase4GoParserSECOND                   = 161
	SqlBase4GoParserSELECT                   = 162
	SqlBase4GoParserSERIALIZABLE             = 163
	SqlBase4GoParserSESSION                  = 164
	SqlBase4GoParserSET                      = 165
	SqlBase4GoParserSETS                     = 166
	SqlBase4GoParserSHOW                     = 167
	SqlBase4GoParserSOME                     = 168
	SqlBase4GoParserSQL                      = 169
	SqlBase4GoParserSTART                    = 170
	SqlBase4GoParserSTATS                    = 171
	SqlBase4GoParserSUBSTRING                = 172
	SqlBase4GoParserSYSTEM                   = 173
	SqlBase4GoParserTABLE                    = 174
	SqlBase4GoParserTABLES                   = 175
	SqlBase4GoParserTABLESAMPLE              = 176
	SqlBase4GoParserTEXT                     = 177
	SqlBase4GoParserTHEN                     = 178
	SqlBase4GoParserTIME                     = 179
	SqlBase4GoParserTIMESTAMP                = 180
	SqlBase4GoParserTO                       = 181
	SqlBase4GoParserTRANSACTION              = 182
	SqlBase4GoParserTRUE                     = 183
	SqlBase4GoParserTRY_CAST                 = 184
	SqlBase4GoParserTYPE                     = 185
	SqlBase4GoParserUESCAPE                  = 186
	SqlBase4GoParserUNBOUNDED                = 187
	SqlBase4GoParserUNCOMMITTED              = 188
	SqlBase4GoParserUNION                    = 189
	SqlBase4GoParserUNNEST                   = 190
	SqlBase4GoParserUSE                      = 191
	SqlBase4GoParserUSER                     = 192
	SqlBase4GoParserUSING                    = 193
	SqlBase4GoParserVALIDATE                 = 194
	SqlBase4GoParserVALUES                   = 195
	SqlBase4GoParserVERBOSE                  = 196
	SqlBase4GoParserVIEW                     = 197
	SqlBase4GoParserWHEN                     = 198
	SqlBase4GoParserWHERE                    = 199
	SqlBase4GoParserWITH                     = 200
	SqlBase4GoParserWORK                     = 201
	SqlBase4GoParserWRITE                    = 202
	SqlBase4GoParserYEAR                     = 203
	SqlBase4GoParserZONE                     = 204
	SqlBase4GoParserEQ                       = 205
	SqlBase4GoParserNEQ                      = 206
	SqlBase4GoParserLT                       = 207
	SqlBase4GoParserLTE                      = 208
	SqlBase4GoParserGT                       = 209
	SqlBase4GoParserGTE                      = 210
	SqlBase4GoParserPLUS                     = 211
	SqlBase4GoParserMINUS                    = 212
	SqlBase4GoParserASTERISK                 = 213
	SqlBase4GoParserSLASH                    = 214
	SqlBase4GoParserPERCENT                  = 215
	SqlBase4GoParserCONCAT                   = 216
	SqlBase4GoParserSTRING                   = 217
	SqlBase4GoParserUNICODE_STRING           = 218
	SqlBase4GoParserBINARY_LITERAL           = 219
	SqlBase4GoParserINTEGER_VALUE            = 220
	SqlBase4GoParserDECIMAL_VALUE            = 221
	SqlBase4GoParserDOUBLE_VALUE             = 222
	SqlBase4GoParserIDENTIFIER               = 223
	SqlBase4GoParserDIGIT_IDENTIFIER         = 224
	SqlBase4GoParserQUOTED_IDENTIFIER        = 225
	SqlBase4GoParserBACKQUOTED_IDENTIFIER    = 226
	SqlBase4GoParserTIME_WITH_TIME_ZONE      = 227
	SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE = 228
	SqlBase4GoParserDOUBLE_PRECISION         = 229
	SqlBase4GoParserSIMPLE_COMMENT           = 230
	SqlBase4GoParserBRACKETED_COMMENT        = 231
	SqlBase4GoParserWS                       = 232
	SqlBase4GoParserUNRECOGNIZED             = 233
	SqlBase4GoParserDELIMITER                = 234
)

// SqlBase4GoParser rules.
const (
	SqlBase4GoParserRULE_singleStatement             = 0
	SqlBase4GoParserRULE_standaloneExpression        = 1
	SqlBase4GoParserRULE_standaloneRoutineBody       = 2
	SqlBase4GoParserRULE_statement                   = 3
	SqlBase4GoParserRULE_query                       = 4
	SqlBase4GoParserRULE_with                        = 5
	SqlBase4GoParserRULE_tableElement                = 6
	SqlBase4GoParserRULE_columnDefinition            = 7
	SqlBase4GoParserRULE_likeClause                  = 8
	SqlBase4GoParserRULE_properties                  = 9
	SqlBase4GoParserRULE_property                    = 10
	SqlBase4GoParserRULE_sqlParameterDeclaration     = 11
	SqlBase4GoParserRULE_routineCharacteristics      = 12
	SqlBase4GoParserRULE_routineCharacteristic       = 13
	SqlBase4GoParserRULE_alterRoutineCharacteristics = 14
	SqlBase4GoParserRULE_alterRoutineCharacteristic  = 15
	SqlBase4GoParserRULE_routineBody                 = 16
	SqlBase4GoParserRULE_returnStatement             = 17
	SqlBase4GoParserRULE_language                    = 18
	SqlBase4GoParserRULE_determinism                 = 19
	SqlBase4GoParserRULE_nullCallClause              = 20
	SqlBase4GoParserRULE_queryNoWith                 = 21
	SqlBase4GoParserRULE_queryTerm                   = 22
	SqlBase4GoParserRULE_queryPrimary                = 23
	SqlBase4GoParserRULE_sortItem                    = 24
	SqlBase4GoParserRULE_querySpecification          = 25
	SqlBase4GoParserRULE_groupBy                     = 26
	SqlBase4GoParserRULE_groupingElement             = 27
	SqlBase4GoParserRULE_groupingSet                 = 28
	SqlBase4GoParserRULE_namedQuery                  = 29
	SqlBase4GoParserRULE_setQuantifier               = 30
	SqlBase4GoParserRULE_selectItem                  = 31
	SqlBase4GoParserRULE_relation                    = 32
	SqlBase4GoParserRULE_joinType                    = 33
	SqlBase4GoParserRULE_joinCriteria                = 34
	SqlBase4GoParserRULE_sampledRelation             = 35
	SqlBase4GoParserRULE_sampleType                  = 36
	SqlBase4GoParserRULE_aliasedRelation             = 37
	SqlBase4GoParserRULE_columnAliases               = 38
	SqlBase4GoParserRULE_relationPrimary             = 39
	SqlBase4GoParserRULE_expression                  = 40
	SqlBase4GoParserRULE_booleanExpression           = 41
	SqlBase4GoParserRULE_predicate                   = 42
	SqlBase4GoParserRULE_valueExpression             = 43
	SqlBase4GoParserRULE_primaryExpression           = 44
	SqlBase4GoParserRULE_nullTreatment               = 45
	SqlBase4GoParserRULE_timeZoneSpecifier           = 46
	SqlBase4GoParserRULE_comparisonOperator          = 47
	SqlBase4GoParserRULE_comparisonQuantifier        = 48
	SqlBase4GoParserRULE_booleanValue                = 49
	SqlBase4GoParserRULE_interval                    = 50
	SqlBase4GoParserRULE_intervalField               = 51
	SqlBase4GoParserRULE_normalForm                  = 52
	SqlBase4GoParserRULE_types                       = 53
	SqlBase4GoParserRULE_type_r                      = 54
	SqlBase4GoParserRULE_typeParameter               = 55
	SqlBase4GoParserRULE_baseType                    = 56
	SqlBase4GoParserRULE_whenClause                  = 57
	SqlBase4GoParserRULE_filter                      = 58
	SqlBase4GoParserRULE_over                        = 59
	SqlBase4GoParserRULE_windowFrame                 = 60
	SqlBase4GoParserRULE_frameBound                  = 61
	SqlBase4GoParserRULE_explainOption               = 62
	SqlBase4GoParserRULE_transactionMode             = 63
	SqlBase4GoParserRULE_levelOfIsolation            = 64
	SqlBase4GoParserRULE_callArgument                = 65
	SqlBase4GoParserRULE_privilege                   = 66
	SqlBase4GoParserRULE_qualifiedName               = 67
	SqlBase4GoParserRULE_grantor                     = 68
	SqlBase4GoParserRULE_principal                   = 69
	SqlBase4GoParserRULE_roles                       = 70
	SqlBase4GoParserRULE_identifier                  = 71
	SqlBase4GoParserRULE_number                      = 72
	SqlBase4GoParserRULE_nonReserved                 = 73
)

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEOF, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *SqlBase4GoParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBase4GoParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(148)
		p.Statement()
	}
	{
		p.SetState(149)
		p.Match(SqlBase4GoParserEOF)
	}

	return localctx
}

// IStandaloneExpressionContext is an interface to support dynamic dispatch.
type IStandaloneExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneExpressionContext differentiates from other interfaces.
	IsStandaloneExpressionContext()
}

type StandaloneExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneExpressionContext() *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_standaloneExpression
	return p
}

func (*StandaloneExpressionContext) IsStandaloneExpressionContext() {}

func NewStandaloneExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_standaloneExpression

	return p
}

func (s *StandaloneExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StandaloneExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEOF, 0)
}

func (s *StandaloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitStandaloneExpression(s)
	}
}

func (p *SqlBase4GoParser) StandaloneExpression() (localctx IStandaloneExpressionContext) {
	localctx = NewStandaloneExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBase4GoParserRULE_standaloneExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(151)
		p.Expression()
	}
	{
		p.SetState(152)
		p.Match(SqlBase4GoParserEOF)
	}

	return localctx
}

// IStandaloneRoutineBodyContext is an interface to support dynamic dispatch.
type IStandaloneRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandaloneRoutineBodyContext differentiates from other interfaces.
	IsStandaloneRoutineBodyContext()
}

type StandaloneRoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneRoutineBodyContext() *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_standaloneRoutineBody
	return p
}

func (*StandaloneRoutineBodyContext) IsStandaloneRoutineBodyContext() {}

func NewStandaloneRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_standaloneRoutineBody

	return p
}

func (s *StandaloneRoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneRoutineBodyContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *StandaloneRoutineBodyContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEOF, 0)
}

func (s *StandaloneRoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneRoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneRoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterStandaloneRoutineBody(s)
	}
}

func (s *StandaloneRoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitStandaloneRoutineBody(s)
	}
}

func (p *SqlBase4GoParser) StandaloneRoutineBody() (localctx IStandaloneRoutineBodyContext) {
	localctx = NewStandaloneRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBase4GoParserRULE_standaloneRoutineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.RoutineBody()
	}
	{
		p.SetState(155)
		p.Match(SqlBase4GoParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserANALYZE, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVERBOSE, 0)
}

func (s *ExplainContext) AllExplainOption() []IExplainOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem())
	var tst = make([]IExplainOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExplainOptionContext)
		}
	}

	return tst
}

func (s *ExplainContext) ExplainOption(i int) IExplainOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExplain(s)
	}
}

type PrepareContext struct {
	*StatementContext
}

func NewPrepareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrepareContext {
	var p = new(PrepareContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPREPARE, 0)
}

func (s *PrepareContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *PrepareContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterPrepare(s)
	}
}

func (s *PrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitPrepare(s)
	}
}

type UseContext struct {
	*StatementContext
	schema  IIdentifierContext
	catalog IIdentifierContext
}

func NewUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseContext {
	var p = new(UseContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UseContext) GetSchema() IIdentifierContext { return s.schema }

func (s *UseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseContext) SetSchema(v IIdentifierContext) { s.schema = v }

func (s *UseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSE, 0)
}

func (s *UseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *UseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUse(s)
	}
}

type DeallocateContext struct {
	*StatementContext
}

func NewDeallocateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeallocateContext {
	var p = new(DeallocateContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeallocateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDEALLOCATE, 0)
}

func (s *DeallocateContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPREPARE, 0)
}

func (s *DeallocateContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDeallocate(s)
	}
}

func (s *DeallocateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDeallocate(s)
	}
}

type RenameTableContext struct {
	*StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameTableContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameTableContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRENAME, 0)
}

func (s *RenameTableContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *RenameTableContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *RenameTableContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

type CommitContext struct {
	*StatementContext
}

func NewCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommitContext {
	var p = new(CommitContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMIT, 0)
}

func (s *CommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWORK, 0)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCommit(s)
	}
}

type CreateRoleContext struct {
	*StatementContext
	name IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *CreateRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *CreateRoleContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADMIN, 0)
}

func (s *CreateRoleContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

type ShowCreateFunctionContext struct {
	*StatementContext
}

func NewShowCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFunctionContext {
	var p = new(ShowCreateFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowCreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *ShowCreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTION, 0)
}

func (s *ShowCreateFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *ShowCreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowCreateFunction(s)
	}
}

func (s *ShowCreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowCreateFunction(s)
	}
}

type DropColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	column    IQualifiedNameContext
}

func NewDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnContext {
	var p = new(DropColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *DropColumnContext) GetColumn() IQualifiedNameContext { return s.column }

func (s *DropColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *DropColumnContext) SetColumn(v IQualifiedNameContext) { s.column = v }

func (s *DropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *DropColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *DropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMN, 0)
}

func (s *DropColumnContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *DropColumnContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropColumn(s)
	}
}

func (s *DropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropColumn(s)
	}
}

type DropViewContext struct {
	*StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVIEW, 0)
}

func (s *DropViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropView(s)
	}
}

type ShowTablesContext struct {
	*StatementContext
	pattern antlr.Token
	escape  antlr.Token
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowTablesContext) GetEscape() antlr.Token { return s.escape }

func (s *ShowTablesContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowTablesContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLES, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *ShowTablesContext) AllMyString() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserMyString)
}

func (s *ShowTablesContext) MyString(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, i)
}

func (s *ShowTablesContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserESCAPE, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type ShowCatalogsContext struct {
	*StatementContext
	pattern antlr.Token
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowCatalogsContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *ShowCatalogsContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type ShowRolesContext struct {
	*StatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLES, 0)
}

func (s *ShowRolesContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT, 0)
}

func (s *ShowRolesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ShowRolesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

type RenameColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	from      IIdentifierContext
	to        IIdentifierContext
}

func NewRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnContext {
	var p = new(RenameColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *RenameColumnContext) GetFrom() IIdentifierContext { return s.from }

func (s *RenameColumnContext) GetTo() IIdentifierContext { return s.to }

func (s *RenameColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *RenameColumnContext) SetFrom(v IIdentifierContext) { s.from = v }

func (s *RenameColumnContext) SetTo(v IIdentifierContext) { s.to = v }

func (s *RenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *RenameColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *RenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRENAME, 0)
}

func (s *RenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMN, 0)
}

func (s *RenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *RenameColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameColumnContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RenameColumnContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRenameColumn(s)
	}
}

func (s *RenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRenameColumn(s)
	}
}

type RevokeRolesContext struct {
	*StatementContext
}

func NewRevokeRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRolesContext {
	var p = new(RevokeRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RevokeRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRolesContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREVOKE, 0)
}

func (s *RevokeRolesContext) Roles() IRolesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRolesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *RevokeRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *RevokeRolesContext) AllPrincipal() []IPrincipalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrincipalContext)(nil)).Elem())
	var tst = make([]IPrincipalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrincipalContext)
		}
	}

	return tst
}

func (s *RevokeRolesContext) Principal(i int) IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADMIN, 0)
}

func (s *RevokeRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOPTION, 0)
}

func (s *RevokeRolesContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOR, 0)
}

func (s *RevokeRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTED, 0)
}

func (s *RevokeRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, 0)
}

func (s *RevokeRolesContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *RevokeRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRevokeRoles(s)
	}
}

type ShowCreateTableContext struct {
	*StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *ShowCreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ShowColumnsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESC, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ShowRoleGrantsContext struct {
	*StatementContext
}

func NewShowRoleGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowRoleGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoleGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowRoleGrantsContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *ShowRoleGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTS, 0)
}

func (s *ShowRoleGrantsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoleGrantsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ShowRoleGrantsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *ShowRoleGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowRoleGrants(s)
	}
}

type AddColumnContext struct {
	*StatementContext
	tableName IQualifiedNameContext
	column    IColumnDefinitionContext
}

func NewAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnContext {
	var p = new(AddColumnContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AddColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *AddColumnContext) GetColumn() IColumnDefinitionContext { return s.column }

func (s *AddColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *AddColumnContext) SetColumn(v IColumnDefinitionContext) { s.column = v }

func (s *AddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *AddColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *AddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADD, 0)
}

func (s *AddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMN, 0)
}

func (s *AddColumnContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAddColumn(s)
	}
}

func (s *AddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAddColumn(s)
	}
}

type ResetSessionContext struct {
	*StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESET, 0)
}

func (s *ResetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSESSION, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitResetSession(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTO, 0)
}

func (s *InsertIntoContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type ShowSessionContext struct {
	*StatementContext
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSESSION, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowSession(s)
	}
}

type CreateSchemaContext struct {
	*StatementContext
}

func NewCreateSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSchemaContext {
	var p = new(CreateSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMA, 0)
}

func (s *CreateSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *CreateSchemaContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *CreateSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *CreateSchemaContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *CreateSchemaContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateSchema(s)
	}
}

func (s *CreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateSchema(s)
	}
}

type ExecuteContext struct {
	*StatementContext
}

func NewExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteContext {
	var p = new(ExecuteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXECUTE, 0)
}

func (s *ExecuteContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSING, 0)
}

func (s *ExecuteContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExecuteContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExecute(s)
	}
}

type RenameSchemaContext struct {
	*StatementContext
}

func NewRenameSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameSchemaContext {
	var p = new(RenameSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RenameSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameSchemaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *RenameSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMA, 0)
}

func (s *RenameSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameSchemaContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRENAME, 0)
}

func (s *RenameSchemaContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *RenameSchemaContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRenameSchema(s)
	}
}

func (s *RenameSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRenameSchema(s)
	}
}

type DropRoleContext struct {
	*StatementContext
	name IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *DropRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropRole(s)
	}
}

type AnalyzeContext struct {
	*StatementContext
}

func NewAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeContext {
	var p = new(AnalyzeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserANALYZE, 0)
}

func (s *AnalyzeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnalyzeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *AnalyzeContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAnalyze(s)
	}
}

func (s *AnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAnalyze(s)
	}
}

type SetRoleContext struct {
	*StatementContext
	role IIdentifierContext
}

func NewSetRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetRoleContext {
	var p = new(SetRoleContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetRoleContext) GetRole() IIdentifierContext { return s.role }

func (s *SetRoleContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSET, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNONE, 0)
}

func (s *SetRoleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSetRole(s)
	}
}

type CreateFunctionContext struct {
	*StatementContext
	functionName IQualifiedNameContext
	returnType   IType_rContext
}

func NewCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateFunctionContext) GetFunctionName() IQualifiedNameContext { return s.functionName }

func (s *CreateFunctionContext) GetReturnType() IType_rContext { return s.returnType }

func (s *CreateFunctionContext) SetFunctionName(v IQualifiedNameContext) { s.functionName = v }

func (s *CreateFunctionContext) SetReturnType(v IType_rContext) { s.returnType = v }

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTION, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRETURNS, 0)
}

func (s *CreateFunctionContext) RoutineCharacteristics() IRoutineCharacteristicsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineCharacteristicsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicsContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionContext) Type_r() IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *CreateFunctionContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOR, 0)
}

func (s *CreateFunctionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREPLACE, 0)
}

func (s *CreateFunctionContext) AllSqlParameterDeclaration() []ISqlParameterDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem())
	var tst = make([]ISqlParameterDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISqlParameterDeclarationContext)
		}
	}

	return tst
}

func (s *CreateFunctionContext) SqlParameterDeclaration(i int) ISqlParameterDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlParameterDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISqlParameterDeclarationContext)
}

func (s *CreateFunctionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMENT, 0)
}

func (s *CreateFunctionContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

type ShowGrantsContext struct {
	*StatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTS, 0)
}

func (s *ShowGrantsContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserON, 0)
}

func (s *ShowGrantsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowGrantsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

type DropSchemaContext struct {
	*StatementContext
}

func NewDropSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSchemaContext {
	var p = new(DropSchemaContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMA, 0)
}

func (s *DropSchemaContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *DropSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *DropSchemaContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCASCADE, 0)
}

func (s *DropSchemaContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESTRICT, 0)
}

func (s *DropSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropSchema(s)
	}
}

func (s *DropSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropSchema(s)
	}
}

type ShowCreateViewContext struct {
	*StatementContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVIEW, 0)
}

func (s *ShowCreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *CreateTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableContext) AllTableElement() []ITableElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementContext)(nil)).Elem())
	var tst = make([]ITableElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementContext)
		}
	}

	return tst
}

func (s *CreateTableContext) TableElement(i int) ITableElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMENT, 0)
}

func (s *CreateTableContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *CreateTableContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type StartTransactionContext struct {
	*StatementContext
}

func NewStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartTransactionContext {
	var p = new(StartTransactionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem())
	var tst = make([]ITransactionModeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITransactionModeContext)
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionModeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

type CreateTableAsSelectContext struct {
	*StatementContext
}

func NewCreateTableAsSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *CreateTableAsSelectContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *CreateTableAsSelectContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsSelectContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *CreateTableAsSelectContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *CreateTableAsSelectContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *CreateTableAsSelectContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateTableAsSelectContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMENT, 0)
}

func (s *CreateTableAsSelectContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *CreateTableAsSelectContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserWITH)
}

func (s *CreateTableAsSelectContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, i)
}

func (s *CreateTableAsSelectContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDATA, 0)
}

func (s *CreateTableAsSelectContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNO, 0)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

type ShowStatsContext struct {
	*StatementContext
}

func NewShowStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsContext {
	var p = new(ShowStatsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSTATS, 0)
}

func (s *ShowStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOR, 0)
}

func (s *ShowStatsContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowStats(s)
	}
}

func (s *ShowStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowStats(s)
	}
}

type DropFunctionContext struct {
	*StatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTION, 0)
}

func (s *DropFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *DropFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

type RevokeContext struct {
	*StatementContext
	grantee IPrincipalContext
}

func NewRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeContext {
	var p = new(RevokeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RevokeContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *RevokeContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREVOKE, 0)
}

func (s *RevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserON, 0)
}

func (s *RevokeContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *RevokeContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *RevokeContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *RevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *RevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRIVILEGES, 0)
}

func (s *RevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANT, 0)
}

func (s *RevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOPTION, 0)
}

func (s *RevokeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOR, 0)
}

func (s *RevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRevoke(s)
	}
}

type DeleteContext struct {
	*StatementContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *DeleteContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWHERE, 0)
}

func (s *DeleteContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDelete(s)
	}
}

type DescribeInputContext struct {
	*StatementContext
}

func NewDescribeInputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeInputContext {
	var p = new(DescribeInputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESCRIBE, 0)
}

func (s *DescribeInputContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINPUT, 0)
}

func (s *DescribeInputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDescribeInput(s)
	}
}

func (s *DescribeInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDescribeInput(s)
	}
}

type ShowStatsForQueryContext struct {
	*StatementContext
}

func NewShowStatsForQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsForQueryContext {
	var p = new(ShowStatsForQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsForQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsForQueryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowStatsForQueryContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSTATS, 0)
}

func (s *ShowStatsForQueryContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOR, 0)
}

func (s *ShowStatsForQueryContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *ShowStatsForQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowStatsForQuery(s)
	}
}

type StatementDefaultContext struct {
	*StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type AlterFunctionContext struct {
	*StatementContext
}

func NewAlterFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTION, 0)
}

func (s *AlterFunctionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterFunctionContext) AlterRoutineCharacteristics() IAlterRoutineCharacteristicsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterRoutineCharacteristicsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineCharacteristicsContext)
}

func (s *AlterFunctionContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

type SetSessionContext struct {
	*StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSET, 0)
}

func (s *SetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSESSION, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEQ, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSetSession(s)
	}
}

type CreateViewContext struct {
	*StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVIEW, 0)
}

func (s *CreateViewContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREPLACE, 0)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type ShowSchemasContext struct {
	*StatementContext
	pattern antlr.Token
	escape  antlr.Token
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowSchemasContext) GetEscape() antlr.Token { return s.escape }

func (s *ShowSchemasContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowSchemasContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowSchemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMAS, 0)
}

func (s *ShowSchemasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *ShowSchemasContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ShowSchemasContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *ShowSchemasContext) AllMyString() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserMyString)
}

func (s *ShowSchemasContext) MyString(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, i)
}

func (s *ShowSchemasContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserESCAPE, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *DropTableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type RollbackContext struct {
	*StatementContext
}

func NewRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollbackContext {
	var p = new(RollbackContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLLBACK, 0)
}

func (s *RollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWORK, 0)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRollback(s)
	}
}

type GrantRolesContext struct {
	*StatementContext
}

func NewGrantRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRolesContext {
	var p = new(GrantRolesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *GrantRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRolesContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANT, 0)
}

func (s *GrantRolesContext) Roles() IRolesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRolesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *GrantRolesContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *GrantRolesContext) AllPrincipal() []IPrincipalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrincipalContext)(nil)).Elem())
	var tst = make([]IPrincipalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrincipalContext)
		}
	}

	return tst
}

func (s *GrantRolesContext) Principal(i int) IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantRolesContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *GrantRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADMIN, 0)
}

func (s *GrantRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOPTION, 0)
}

func (s *GrantRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTED, 0)
}

func (s *GrantRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, 0)
}

func (s *GrantRolesContext) Grantor() IGrantorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *GrantRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterGrantRoles(s)
	}
}

func (s *GrantRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitGrantRoles(s)
	}
}

type CallContext struct {
	*StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCALL, 0)
}

func (s *CallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CallContext) AllCallArgument() []ICallArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem())
	var tst = make([]ICallArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallArgumentContext)
		}
	}

	return tst
}

func (s *CallContext) CallArgument(i int) ICallArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCall(s)
	}
}

type ShowFunctionsContext struct {
	*StatementContext
	pattern antlr.Token
	escape  antlr.Token
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetPattern() antlr.Token { return s.pattern }

func (s *ShowFunctionsContext) GetEscape() antlr.Token { return s.escape }

func (s *ShowFunctionsContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *ShowFunctionsContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *ShowFunctionsContext) AllMyString() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserMyString)
}

func (s *ShowFunctionsContext) MyString(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, i)
}

func (s *ShowFunctionsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserESCAPE, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type DescribeOutputContext struct {
	*StatementContext
}

func NewDescribeOutputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeOutputContext {
	var p = new(DescribeOutputContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeOutputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESCRIBE, 0)
}

func (s *DescribeOutputContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOUTPUT, 0)
}

func (s *DescribeOutputContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDescribeOutput(s)
	}
}

type GrantContext struct {
	*StatementContext
	grantee IPrincipalContext
}

func NewGrantContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantContext {
	var p = new(GrantContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *GrantContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *GrantContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserGRANT)
}

func (s *GrantContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANT, i)
}

func (s *GrantContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserON, 0)
}

func (s *GrantContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GrantContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *GrantContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantContext) AllPrivilege() []IPrivilegeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem())
	var tst = make([]IPrivilegeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeContext)
		}
	}

	return tst
}

func (s *GrantContext) Privilege(i int) IPrivilegeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *GrantContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *GrantContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRIVILEGES, 0)
}

func (s *GrantContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *GrantContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *GrantContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOPTION, 0)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (p *SqlBase4GoParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBase4GoParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(157)
			p.Query()
		}

	case 2:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(158)
			p.Match(SqlBase4GoParserUSE)
		}
		{
			p.SetState(159)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 3:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(160)
			p.Match(SqlBase4GoParserUSE)
		}
		{
			p.SetState(161)

			var _x = p.Identifier()

			localctx.(*UseContext).catalog = _x
		}
		{
			p.SetState(162)
			p.Match(SqlBase4GoParserT__0)
		}
		{
			p.SetState(163)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 4:
		localctx = NewCreateSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(165)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(166)
			p.Match(SqlBase4GoParserSCHEMA)
		}
		p.SetState(170)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(167)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(168)
				p.Match(SqlBase4GoParserNOT)
			}
			{
				p.SetState(169)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(172)
			p.QualifiedName()
		}
		p.SetState(175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(173)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(174)
				p.Properties()
			}

		}

	case 5:
		localctx = NewDropSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(177)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(178)
			p.Match(SqlBase4GoParserSCHEMA)
		}
		p.SetState(181)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(179)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(180)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(183)
			p.QualifiedName()
		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserCASCADE || _la == SqlBase4GoParserRESTRICT {
			{
				p.SetState(184)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBase4GoParserCASCADE || _la == SqlBase4GoParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 6:
		localctx = NewRenameSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(187)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(188)
			p.Match(SqlBase4GoParserSCHEMA)
		}
		{
			p.SetState(189)
			p.QualifiedName()
		}
		{
			p.SetState(190)
			p.Match(SqlBase4GoParserRENAME)
		}
		{
			p.SetState(191)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(192)
			p.Identifier()
		}

	case 7:
		localctx = NewCreateTableAsSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(194)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(195)
			p.Match(SqlBase4GoParserTABLE)
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(196)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(197)
				p.Match(SqlBase4GoParserNOT)
			}
			{
				p.SetState(198)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(201)
			p.QualifiedName()
		}
		p.SetState(203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserT__1 {
			{
				p.SetState(202)
				p.ColumnAliases()
			}

		}
		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserCOMMENT {
			{
				p.SetState(205)
				p.Match(SqlBase4GoParserCOMMENT)
			}
			{
				p.SetState(206)
				p.Match(SqlBase4GoParserMyString)
			}

		}
		p.SetState(211)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(209)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(210)
				p.Properties()
			}

		}
		{
			p.SetState(213)
			p.Match(SqlBase4GoParserAS)
		}
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(214)
				p.Query()
			}

		case 2:
			{
				p.SetState(215)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(216)
				p.Query()
			}
			{
				p.SetState(217)
				p.Match(SqlBase4GoParserT__2)
			}

		}
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(221)
				p.Match(SqlBase4GoParserWITH)
			}
			p.SetState(223)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserNO {
				{
					p.SetState(222)
					p.Match(SqlBase4GoParserNO)
				}

			}
			{
				p.SetState(225)
				p.Match(SqlBase4GoParserDATA)
			}

		}

	case 8:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(228)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(229)
			p.Match(SqlBase4GoParserTABLE)
		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(230)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(231)
				p.Match(SqlBase4GoParserNOT)
			}
			{
				p.SetState(232)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(235)
			p.QualifiedName()
		}
		{
			p.SetState(236)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(237)
			p.TableElement()
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(238)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(239)
				p.TableElement()
			}

			p.SetState(244)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(245)
			p.Match(SqlBase4GoParserT__2)
		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserCOMMENT {
			{
				p.SetState(246)
				p.Match(SqlBase4GoParserCOMMENT)
			}
			{
				p.SetState(247)
				p.Match(SqlBase4GoParserMyString)
			}

		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(250)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(251)
				p.Properties()
			}

		}

	case 9:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(254)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(255)
			p.Match(SqlBase4GoParserTABLE)
		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(256)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(257)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(260)
			p.QualifiedName()
		}

	case 10:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(261)
			p.Match(SqlBase4GoParserINSERT)
		}
		{
			p.SetState(262)
			p.Match(SqlBase4GoParserINTO)
		}
		{
			p.SetState(263)
			p.QualifiedName()
		}
		p.SetState(265)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(264)
				p.ColumnAliases()
			}

		}
		{
			p.SetState(267)
			p.Query()
		}

	case 11:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(269)
			p.Match(SqlBase4GoParserDELETE)
		}
		{
			p.SetState(270)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(271)
			p.QualifiedName()
		}
		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWHERE {
			{
				p.SetState(272)
				p.Match(SqlBase4GoParserWHERE)
			}
			{
				p.SetState(273)
				p.booleanExpression(0)
			}

		}

	case 12:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(276)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(277)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(278)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(279)
			p.Match(SqlBase4GoParserRENAME)
		}
		{
			p.SetState(280)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(281)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).to = _x
		}

	case 13:
		localctx = NewRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(283)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(284)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(285)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).tableName = _x
		}
		{
			p.SetState(286)
			p.Match(SqlBase4GoParserRENAME)
		}
		{
			p.SetState(287)
			p.Match(SqlBase4GoParserCOLUMN)
		}
		{
			p.SetState(288)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).from = _x
		}
		{
			p.SetState(289)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(290)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).to = _x
		}

	case 14:
		localctx = NewDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(292)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(293)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(294)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).tableName = _x
		}
		{
			p.SetState(295)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(296)
			p.Match(SqlBase4GoParserCOLUMN)
		}
		{
			p.SetState(297)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).column = _x
		}

	case 15:
		localctx = NewAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(299)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(300)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(301)

			var _x = p.QualifiedName()

			localctx.(*AddColumnContext).tableName = _x
		}
		{
			p.SetState(302)
			p.Match(SqlBase4GoParserADD)
		}
		{
			p.SetState(303)
			p.Match(SqlBase4GoParserCOLUMN)
		}
		{
			p.SetState(304)

			var _x = p.ColumnDefinition()

			localctx.(*AddColumnContext).column = _x
		}

	case 16:
		localctx = NewAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(306)
			p.Match(SqlBase4GoParserANALYZE)
		}
		{
			p.SetState(307)
			p.QualifiedName()
		}
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(308)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(309)
				p.Properties()
			}

		}

	case 17:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(312)
			p.Match(SqlBase4GoParserCREATE)
		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserOR {
			{
				p.SetState(313)
				p.Match(SqlBase4GoParserOR)
			}
			{
				p.SetState(314)
				p.Match(SqlBase4GoParserREPLACE)
			}

		}
		{
			p.SetState(317)
			p.Match(SqlBase4GoParserVIEW)
		}
		{
			p.SetState(318)
			p.QualifiedName()
		}
		{
			p.SetState(319)
			p.Match(SqlBase4GoParserAS)
		}
		{
			p.SetState(320)
			p.Query()
		}

	case 18:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(322)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(323)
			p.Match(SqlBase4GoParserVIEW)
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(324)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(325)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(328)
			p.QualifiedName()
		}

	case 19:
		localctx = NewCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(329)
			p.Match(SqlBase4GoParserCREATE)
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserOR {
			{
				p.SetState(330)
				p.Match(SqlBase4GoParserOR)
			}
			{
				p.SetState(331)
				p.Match(SqlBase4GoParserREPLACE)
			}

		}
		{
			p.SetState(334)
			p.Match(SqlBase4GoParserFUNCTION)
		}
		{
			p.SetState(335)

			var _x = p.QualifiedName()

			localctx.(*CreateFunctionContext).functionName = _x
		}
		{
			p.SetState(336)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(SqlBase4GoParserADD-11))|(1<<(SqlBase4GoParserADMIN-11))|(1<<(SqlBase4GoParserALL-11))|(1<<(SqlBase4GoParserANALYZE-11))|(1<<(SqlBase4GoParserANY-11))|(1<<(SqlBase4GoParserARRAY-11))|(1<<(SqlBase4GoParserASC-11))|(1<<(SqlBase4GoParserAT-11))|(1<<(SqlBase4GoParserBERNOULLI-11))|(1<<(SqlBase4GoParserCALL-11))|(1<<(SqlBase4GoParserCALLED-11))|(1<<(SqlBase4GoParserCASCADE-11))|(1<<(SqlBase4GoParserCATALOGS-11))|(1<<(SqlBase4GoParserCOLUMN-11))|(1<<(SqlBase4GoParserCOLUMNS-11))|(1<<(SqlBase4GoParserCOMMENT-11))|(1<<(SqlBase4GoParserCOMMIT-11))|(1<<(SqlBase4GoParserCOMMITTED-11))|(1<<(SqlBase4GoParserCURRENT-11))|(1<<(SqlBase4GoParserCURRENT_ROLE-11)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SqlBase4GoParserDATA-46))|(1<<(SqlBase4GoParserDATE-46))|(1<<(SqlBase4GoParserDAY-46))|(1<<(SqlBase4GoParserDESC-46))|(1<<(SqlBase4GoParserDETERMINISTIC-46))|(1<<(SqlBase4GoParserDISTRIBUTED-46))|(1<<(SqlBase4GoParserEXCLUDING-46))|(1<<(SqlBase4GoParserEXPLAIN-46))|(1<<(SqlBase4GoParserFILTER-46))|(1<<(SqlBase4GoParserFIRST-46))|(1<<(SqlBase4GoParserFOLLOWING-46))|(1<<(SqlBase4GoParserFORMAT-46))|(1<<(SqlBase4GoParserFUNCTION-46))|(1<<(SqlBase4GoParserFUNCTIONS-46))|(1<<(SqlBase4GoParserGRANT-46))|(1<<(SqlBase4GoParserGRANTED-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SqlBase4GoParserGRANTS-78))|(1<<(SqlBase4GoParserGRAPHVIZ-78))|(1<<(SqlBase4GoParserHOUR-78))|(1<<(SqlBase4GoParserIF-78))|(1<<(SqlBase4GoParserIGNORE-78))|(1<<(SqlBase4GoParserINCLUDING-78))|(1<<(SqlBase4GoParserINPUT-78))|(1<<(SqlBase4GoParserINTERVAL-78))|(1<<(SqlBase4GoParserIO-78))|(1<<(SqlBase4GoParserISOLATION-78))|(1<<(SqlBase4GoParserJSON-78))|(1<<(SqlBase4GoParserLANGUAGE-78))|(1<<(SqlBase4GoParserLAST-78))|(1<<(SqlBase4GoParserLATERAL-78))|(1<<(SqlBase4GoParserLEVEL-78))|(1<<(SqlBase4GoParserLIMIT-78))|(1<<(SqlBase4GoParserLOGICAL-78))|(1<<(SqlBase4GoParserMAP-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBase4GoParserMINUTE-110))|(1<<(SqlBase4GoParserMONTH-110))|(1<<(SqlBase4GoParserNFC-110))|(1<<(SqlBase4GoParserNFD-110))|(1<<(SqlBase4GoParserNFKC-110))|(1<<(SqlBase4GoParserNFKD-110))|(1<<(SqlBase4GoParserNO-110))|(1<<(SqlBase4GoParserNONE-110))|(1<<(SqlBase4GoParserNULLIF-110))|(1<<(SqlBase4GoParserNULLS-110))|(1<<(SqlBase4GoParserONLY-110))|(1<<(SqlBase4GoParserOPTION-110))|(1<<(SqlBase4GoParserORDINALITY-110))|(1<<(SqlBase4GoParserOUTPUT-110))|(1<<(SqlBase4GoParserOVER-110))|(1<<(SqlBase4GoParserPARTITION-110))|(1<<(SqlBase4GoParserPARTITIONS-110))|(1<<(SqlBase4GoParserPOSITION-110))|(1<<(SqlBase4GoParserPRECEDING-110))|(1<<(SqlBase4GoParserPRIVILEGES-110))|(1<<(SqlBase4GoParserPROPERTIES-110))|(1<<(SqlBase4GoParserRANGE-110))|(1<<(SqlBase4GoParserREAD-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBase4GoParserRENAME-143))|(1<<(SqlBase4GoParserREPEATABLE-143))|(1<<(SqlBase4GoParserREPLACE-143))|(1<<(SqlBase4GoParserRESET-143))|(1<<(SqlBase4GoParserRESPECT-143))|(1<<(SqlBase4GoParserRESTRICT-143))|(1<<(SqlBase4GoParserRETURN-143))|(1<<(SqlBase4GoParserRETURNS-143))|(1<<(SqlBase4GoParserREVOKE-143))|(1<<(SqlBase4GoParserROLE-143))|(1<<(SqlBase4GoParserROLES-143))|(1<<(SqlBase4GoParserROLLBACK-143))|(1<<(SqlBase4GoParserROW-143))|(1<<(SqlBase4GoParserROWS-143))|(1<<(SqlBase4GoParserSCHEMA-143))|(1<<(SqlBase4GoParserSCHEMAS-143))|(1<<(SqlBase4GoParserSECOND-143))|(1<<(SqlBase4GoParserSERIALIZABLE-143))|(1<<(SqlBase4GoParserSESSION-143))|(1<<(SqlBase4GoParserSET-143))|(1<<(SqlBase4GoParserSETS-143))|(1<<(SqlBase4GoParserSHOW-143))|(1<<(SqlBase4GoParserSOME-143))|(1<<(SqlBase4GoParserSQL-143))|(1<<(SqlBase4GoParserSTART-143))|(1<<(SqlBase4GoParserSTATS-143))|(1<<(SqlBase4GoParserSUBSTRING-143))|(1<<(SqlBase4GoParserSYSTEM-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBase4GoParserTABLES-175))|(1<<(SqlBase4GoParserTABLESAMPLE-175))|(1<<(SqlBase4GoParserTEXT-175))|(1<<(SqlBase4GoParserTIME-175))|(1<<(SqlBase4GoParserTIMESTAMP-175))|(1<<(SqlBase4GoParserTO-175))|(1<<(SqlBase4GoParserTRANSACTION-175))|(1<<(SqlBase4GoParserTRY_CAST-175))|(1<<(SqlBase4GoParserTYPE-175))|(1<<(SqlBase4GoParserUNBOUNDED-175))|(1<<(SqlBase4GoParserUNCOMMITTED-175))|(1<<(SqlBase4GoParserUSE-175))|(1<<(SqlBase4GoParserUSER-175))|(1<<(SqlBase4GoParserVALIDATE-175))|(1<<(SqlBase4GoParserVERBOSE-175))|(1<<(SqlBase4GoParserVIEW-175))|(1<<(SqlBase4GoParserWORK-175))|(1<<(SqlBase4GoParserWRITE-175))|(1<<(SqlBase4GoParserYEAR-175))|(1<<(SqlBase4GoParserZONE-175)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SqlBase4GoParserIDENTIFIER-223))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-223))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-223))|(1<<(SqlBase4GoParserBACKQUOTED_IDENTIFIER-223)))) != 0) {
			{
				p.SetState(337)
				p.SqlParameterDeclaration()
			}
			p.SetState(342)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(338)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(339)
					p.SqlParameterDeclaration()
				}

				p.SetState(344)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(347)
			p.Match(SqlBase4GoParserT__2)
		}
		{
			p.SetState(348)
			p.Match(SqlBase4GoParserRETURNS)
		}
		{
			p.SetState(349)

			var _x = p.type_r(0)

			localctx.(*CreateFunctionContext).returnType = _x
		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserCOMMENT {
			{
				p.SetState(350)
				p.Match(SqlBase4GoParserCOMMENT)
			}
			{
				p.SetState(351)
				p.Match(SqlBase4GoParserMyString)
			}

		}
		{
			p.SetState(354)
			p.RoutineCharacteristics()
		}
		{
			p.SetState(355)
			p.RoutineBody()
		}

	case 20:
		localctx = NewAlterFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(357)
			p.Match(SqlBase4GoParserALTER)
		}
		{
			p.SetState(358)
			p.Match(SqlBase4GoParserFUNCTION)
		}
		{
			p.SetState(359)
			p.QualifiedName()
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserT__1 {
			{
				p.SetState(360)
				p.Types()
			}

		}
		{
			p.SetState(363)
			p.AlterRoutineCharacteristics()
		}

	case 21:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(365)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(366)
			p.Match(SqlBase4GoParserFUNCTION)
		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(367)
				p.Match(SqlBase4GoParserIF)
			}
			{
				p.SetState(368)
				p.Match(SqlBase4GoParserEXISTS)
			}

		}
		{
			p.SetState(371)
			p.QualifiedName()
		}
		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserT__1 {
			{
				p.SetState(372)
				p.Types()
			}

		}

	case 22:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(375)
			p.Match(SqlBase4GoParserCALL)
		}
		{
			p.SetState(376)
			p.QualifiedName()
		}
		{
			p.SetState(377)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			{
				p.SetState(378)
				p.CallArgument()
			}
			p.SetState(383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(379)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(380)
					p.CallArgument()
				}

				p.SetState(385)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(388)
			p.Match(SqlBase4GoParserT__2)
		}

	case 23:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(390)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(391)
			p.Match(SqlBase4GoParserROLE)
		}
		{
			p.SetState(392)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(393)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(394)
				p.Match(SqlBase4GoParserADMIN)
			}
			{
				p.SetState(395)
				p.Grantor()
			}

		}

	case 24:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(398)
			p.Match(SqlBase4GoParserDROP)
		}
		{
			p.SetState(399)
			p.Match(SqlBase4GoParserROLE)
		}
		{
			p.SetState(400)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}

	case 25:
		localctx = NewGrantRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(401)
			p.Match(SqlBase4GoParserGRANT)
		}
		{
			p.SetState(402)
			p.Roles()
		}
		{
			p.SetState(403)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(404)
			p.Principal()
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(405)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(406)
				p.Principal()
			}

			p.SetState(411)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(412)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(413)
				p.Match(SqlBase4GoParserADMIN)
			}
			{
				p.SetState(414)
				p.Match(SqlBase4GoParserOPTION)
			}

		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserGRANTED {
			{
				p.SetState(417)
				p.Match(SqlBase4GoParserGRANTED)
			}
			{
				p.SetState(418)
				p.Match(SqlBase4GoParserBY)
			}
			{
				p.SetState(419)
				p.Grantor()
			}

		}

	case 26:
		localctx = NewRevokeRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(422)
			p.Match(SqlBase4GoParserREVOKE)
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(423)
				p.Match(SqlBase4GoParserADMIN)
			}
			{
				p.SetState(424)
				p.Match(SqlBase4GoParserOPTION)
			}
			{
				p.SetState(425)
				p.Match(SqlBase4GoParserFOR)
			}

		}
		{
			p.SetState(428)
			p.Roles()
		}
		{
			p.SetState(429)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(430)
			p.Principal()
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(431)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(432)
				p.Principal()
			}

			p.SetState(437)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserGRANTED {
			{
				p.SetState(438)
				p.Match(SqlBase4GoParserGRANTED)
			}
			{
				p.SetState(439)
				p.Match(SqlBase4GoParserBY)
			}
			{
				p.SetState(440)
				p.Grantor()
			}

		}

	case 27:
		localctx = NewSetRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(443)
			p.Match(SqlBase4GoParserSET)
		}
		{
			p.SetState(444)
			p.Match(SqlBase4GoParserROLE)
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(445)
				p.Match(SqlBase4GoParserALL)
			}

		case 2:
			{
				p.SetState(446)
				p.Match(SqlBase4GoParserNONE)
			}

		case 3:
			{
				p.SetState(447)

				var _x = p.Identifier()

				localctx.(*SetRoleContext).role = _x
			}

		}

	case 28:
		localctx = NewGrantContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(450)
			p.Match(SqlBase4GoParserGRANT)
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(451)
				p.Privilege()
			}
			p.SetState(456)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(452)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(453)
					p.Privilege()
				}

				p.SetState(458)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(459)
				p.Match(SqlBase4GoParserALL)
			}
			{
				p.SetState(460)
				p.Match(SqlBase4GoParserPRIVILEGES)
			}

		}
		{
			p.SetState(463)
			p.Match(SqlBase4GoParserON)
		}
		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserTABLE {
			{
				p.SetState(464)
				p.Match(SqlBase4GoParserTABLE)
			}

		}
		{
			p.SetState(467)
			p.QualifiedName()
		}
		{
			p.SetState(468)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(469)

			var _x = p.Principal()

			localctx.(*GrantContext).grantee = _x
		}
		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWITH {
			{
				p.SetState(470)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(471)
				p.Match(SqlBase4GoParserGRANT)
			}
			{
				p.SetState(472)
				p.Match(SqlBase4GoParserOPTION)
			}

		}

	case 29:
		localctx = NewRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(475)
			p.Match(SqlBase4GoParserREVOKE)
		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(476)
				p.Match(SqlBase4GoParserGRANT)
			}
			{
				p.SetState(477)
				p.Match(SqlBase4GoParserOPTION)
			}
			{
				p.SetState(478)
				p.Match(SqlBase4GoParserFOR)
			}

		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(481)
				p.Privilege()
			}
			p.SetState(486)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(482)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(483)
					p.Privilege()
				}

				p.SetState(488)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(489)
				p.Match(SqlBase4GoParserALL)
			}
			{
				p.SetState(490)
				p.Match(SqlBase4GoParserPRIVILEGES)
			}

		}
		{
			p.SetState(493)
			p.Match(SqlBase4GoParserON)
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserTABLE {
			{
				p.SetState(494)
				p.Match(SqlBase4GoParserTABLE)
			}

		}
		{
			p.SetState(497)
			p.QualifiedName()
		}
		{
			p.SetState(498)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(499)

			var _x = p.Principal()

			localctx.(*RevokeContext).grantee = _x
		}

	case 30:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(501)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(502)
			p.Match(SqlBase4GoParserGRANTS)
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserON {
			{
				p.SetState(503)
				p.Match(SqlBase4GoParserON)
			}
			p.SetState(505)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserTABLE {
				{
					p.SetState(504)
					p.Match(SqlBase4GoParserTABLE)
				}

			}
			{
				p.SetState(507)
				p.QualifiedName()
			}

		}

	case 31:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(510)
			p.Match(SqlBase4GoParserEXPLAIN)
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(511)
				p.Match(SqlBase4GoParserANALYZE)
			}

		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserVERBOSE {
			{
				p.SetState(514)
				p.Match(SqlBase4GoParserVERBOSE)
			}

		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(517)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(518)
				p.ExplainOption()
			}
			p.SetState(523)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(519)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(520)
					p.ExplainOption()
				}

				p.SetState(525)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(526)
				p.Match(SqlBase4GoParserT__2)
			}

		}
		{
			p.SetState(530)
			p.Statement()
		}

	case 32:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(531)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(532)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(533)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(534)
			p.QualifiedName()
		}

	case 33:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(535)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(536)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(537)
			p.Match(SqlBase4GoParserVIEW)
		}
		{
			p.SetState(538)
			p.QualifiedName()
		}

	case 34:
		localctx = NewShowCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(539)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(540)
			p.Match(SqlBase4GoParserCREATE)
		}
		{
			p.SetState(541)
			p.Match(SqlBase4GoParserFUNCTION)
		}
		{
			p.SetState(542)
			p.QualifiedName()
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserT__1 {
			{
				p.SetState(543)
				p.Types()
			}

		}

	case 35:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(546)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(547)
			p.Match(SqlBase4GoParserTABLES)
		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN {
			{
				p.SetState(548)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(549)
				p.QualifiedName()
			}

		}
		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserLIKE {
			{
				p.SetState(552)
				p.Match(SqlBase4GoParserLIKE)
			}
			{
				p.SetState(553)

				var _m = p.Match(SqlBase4GoParserMyString)

				localctx.(*ShowTablesContext).pattern = _m
			}
			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserESCAPE {
				{
					p.SetState(554)
					p.Match(SqlBase4GoParserESCAPE)
				}
				{
					p.SetState(555)

					var _m = p.Match(SqlBase4GoParserMyString)

					localctx.(*ShowTablesContext).escape = _m
				}

			}

		}

	case 36:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(560)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(561)
			p.Match(SqlBase4GoParserSCHEMAS)
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN {
			{
				p.SetState(562)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(563)
				p.Identifier()
			}

		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserLIKE {
			{
				p.SetState(566)
				p.Match(SqlBase4GoParserLIKE)
			}
			{
				p.SetState(567)

				var _m = p.Match(SqlBase4GoParserMyString)

				localctx.(*ShowSchemasContext).pattern = _m
			}
			p.SetState(570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserESCAPE {
				{
					p.SetState(568)
					p.Match(SqlBase4GoParserESCAPE)
				}
				{
					p.SetState(569)

					var _m = p.Match(SqlBase4GoParserMyString)

					localctx.(*ShowSchemasContext).escape = _m
				}

			}

		}

	case 37:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(574)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(575)
			p.Match(SqlBase4GoParserCATALOGS)
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserLIKE {
			{
				p.SetState(576)
				p.Match(SqlBase4GoParserLIKE)
			}
			{
				p.SetState(577)

				var _m = p.Match(SqlBase4GoParserMyString)

				localctx.(*ShowCatalogsContext).pattern = _m
			}

		}

	case 38:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(580)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(581)
			p.Match(SqlBase4GoParserCOLUMNS)
		}
		{
			p.SetState(582)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(583)
			p.QualifiedName()
		}

	case 39:
		localctx = NewShowStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(584)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(585)
			p.Match(SqlBase4GoParserSTATS)
		}
		{
			p.SetState(586)
			p.Match(SqlBase4GoParserFOR)
		}
		{
			p.SetState(587)
			p.QualifiedName()
		}

	case 40:
		localctx = NewShowStatsForQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(588)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(589)
			p.Match(SqlBase4GoParserSTATS)
		}
		{
			p.SetState(590)
			p.Match(SqlBase4GoParserFOR)
		}
		{
			p.SetState(591)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(592)
			p.QuerySpecification()
		}
		{
			p.SetState(593)
			p.Match(SqlBase4GoParserT__2)
		}

	case 41:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(595)
			p.Match(SqlBase4GoParserSHOW)
		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserCURRENT {
			{
				p.SetState(596)
				p.Match(SqlBase4GoParserCURRENT)
			}

		}
		{
			p.SetState(599)
			p.Match(SqlBase4GoParserROLES)
		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN {
			{
				p.SetState(600)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(601)
				p.Identifier()
			}

		}

	case 42:
		localctx = NewShowRoleGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(604)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(605)
			p.Match(SqlBase4GoParserROLE)
		}
		{
			p.SetState(606)
			p.Match(SqlBase4GoParserGRANTS)
		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN {
			{
				p.SetState(607)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBase4GoParserFROM || _la == SqlBase4GoParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(608)
				p.Identifier()
			}

		}

	case 43:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(611)
			p.Match(SqlBase4GoParserDESCRIBE)
		}
		{
			p.SetState(612)
			p.QualifiedName()
		}

	case 44:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(613)
			p.Match(SqlBase4GoParserDESC)
		}
		{
			p.SetState(614)
			p.QualifiedName()
		}

	case 45:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(615)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(616)
			p.Match(SqlBase4GoParserFUNCTIONS)
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserLIKE {
			{
				p.SetState(617)
				p.Match(SqlBase4GoParserLIKE)
			}
			{
				p.SetState(618)

				var _m = p.Match(SqlBase4GoParserMyString)

				localctx.(*ShowFunctionsContext).pattern = _m
			}
			p.SetState(621)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserESCAPE {
				{
					p.SetState(619)
					p.Match(SqlBase4GoParserESCAPE)
				}
				{
					p.SetState(620)

					var _m = p.Match(SqlBase4GoParserMyString)

					localctx.(*ShowFunctionsContext).escape = _m
				}

			}

		}

	case 46:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(625)
			p.Match(SqlBase4GoParserSHOW)
		}
		{
			p.SetState(626)
			p.Match(SqlBase4GoParserSESSION)
		}

	case 47:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(627)
			p.Match(SqlBase4GoParserSET)
		}
		{
			p.SetState(628)
			p.Match(SqlBase4GoParserSESSION)
		}
		{
			p.SetState(629)
			p.QualifiedName()
		}
		{
			p.SetState(630)
			p.Match(SqlBase4GoParserEQ)
		}
		{
			p.SetState(631)
			p.Expression()
		}

	case 48:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(633)
			p.Match(SqlBase4GoParserRESET)
		}
		{
			p.SetState(634)
			p.Match(SqlBase4GoParserSESSION)
		}
		{
			p.SetState(635)
			p.QualifiedName()
		}

	case 49:
		localctx = NewStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(636)
			p.Match(SqlBase4GoParserSTART)
		}
		{
			p.SetState(637)
			p.Match(SqlBase4GoParserTRANSACTION)
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserISOLATION || _la == SqlBase4GoParserREAD {
			{
				p.SetState(638)
				p.TransactionMode()
			}
			p.SetState(643)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(639)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(640)
					p.TransactionMode()
				}

				p.SetState(645)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 50:
		localctx = NewCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(648)
			p.Match(SqlBase4GoParserCOMMIT)
		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWORK {
			{
				p.SetState(649)
				p.Match(SqlBase4GoParserWORK)
			}

		}

	case 51:
		localctx = NewRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(652)
			p.Match(SqlBase4GoParserROLLBACK)
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserWORK {
			{
				p.SetState(653)
				p.Match(SqlBase4GoParserWORK)
			}

		}

	case 52:
		localctx = NewPrepareContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(656)
			p.Match(SqlBase4GoParserPREPARE)
		}
		{
			p.SetState(657)
			p.Identifier()
		}
		{
			p.SetState(658)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(659)
			p.Statement()
		}

	case 53:
		localctx = NewDeallocateContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(661)
			p.Match(SqlBase4GoParserDEALLOCATE)
		}
		{
			p.SetState(662)
			p.Match(SqlBase4GoParserPREPARE)
		}
		{
			p.SetState(663)
			p.Identifier()
		}

	case 54:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(664)
			p.Match(SqlBase4GoParserEXECUTE)
		}
		{
			p.SetState(665)
			p.Identifier()
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserUSING {
			{
				p.SetState(666)
				p.Match(SqlBase4GoParserUSING)
			}
			{
				p.SetState(667)
				p.Expression()
			}
			p.SetState(672)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(668)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(669)
					p.Expression()
				}

				p.SetState(674)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 55:
		localctx = NewDescribeInputContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(677)
			p.Match(SqlBase4GoParserDESCRIBE)
		}
		{
			p.SetState(678)
			p.Match(SqlBase4GoParserINPUT)
		}
		{
			p.SetState(679)
			p.Identifier()
		}

	case 56:
		localctx = NewDescribeOutputContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(680)
			p.Match(SqlBase4GoParserDESCRIBE)
		}
		{
			p.SetState(681)
			p.Match(SqlBase4GoParserOUTPUT)
		}
		{
			p.SetState(682)
			p.Identifier()
		}

	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *SqlBase4GoParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBase4GoParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserWITH {
		{
			p.SetState(685)
			p.With()
		}

	}
	{
		p.SetState(688)
		p.QueryNoWith()
	}

	return localctx
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_with
	return p
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedQueryContext)(nil)).Elem())
	var tst = make([]INamedQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedQueryContext)
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitWith(s)
	}
}

func (p *SqlBase4GoParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBase4GoParserRULE_with)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(SqlBase4GoParserWITH)
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserRECURSIVE {
		{
			p.SetState(691)
			p.Match(SqlBase4GoParserRECURSIVE)
		}

	}
	{
		p.SetState(694)
		p.NamedQuery()
	}
	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserT__3 {
		{
			p.SetState(695)
			p.Match(SqlBase4GoParserT__3)
		}
		{
			p.SetState(696)
			p.NamedQuery()
		}

		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILikeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *SqlBase4GoParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlBase4GoParserRULE_tableElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(704)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXPLAIN, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.ColumnDefinition()
		}

	case SqlBase4GoParserLIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(703)
			p.LikeClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) Type_r() IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *ColumnDefinitionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULL, 0)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *ColumnDefinitionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *ColumnDefinitionContext) Properties() IPropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *SqlBase4GoParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBase4GoParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Identifier()
	}
	{
		p.SetState(707)
		p.type_r(0)
	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserNOT {
		{
			p.SetState(708)
			p.Match(SqlBase4GoParserNOT)
		}
		{
			p.SetState(709)
			p.Match(SqlBase4GoParserNULL)
		}

	}
	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserCOMMENT {
		{
			p.SetState(712)
			p.Match(SqlBase4GoParserCOMMENT)
		}
		{
			p.SetState(713)
			p.Match(SqlBase4GoParserMyString)
		}

	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserWITH {
		{
			p.SetState(716)
			p.Match(SqlBase4GoParserWITH)
		}
		{
			p.SetState(717)
			p.Properties()
		}

	}

	return localctx
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_likeClause
	return p
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPROPERTIES, 0)
}

func (s *LikeClauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINCLUDING, 0)
}

func (s *LikeClauseContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXCLUDING, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (p *SqlBase4GoParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBase4GoParserRULE_likeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Match(SqlBase4GoParserLIKE)
	}
	{
		p.SetState(721)
		p.QualifiedName()
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserEXCLUDING || _la == SqlBase4GoParserINCLUDING {
		{
			p.SetState(722)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeClauseContext).optionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserEXCLUDING || _la == SqlBase4GoParserINCLUDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeClauseContext).optionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(723)
			p.Match(SqlBase4GoParserPROPERTIES)
		}

	}

	return localctx
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_properties
	return p
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyContext)(nil)).Elem())
	var tst = make([]IPropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyContext)
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (p *SqlBase4GoParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBase4GoParserRULE_properties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(SqlBase4GoParserT__1)
	}
	{
		p.SetState(727)
		p.Property()
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserT__3 {
		{
			p.SetState(728)
			p.Match(SqlBase4GoParserT__3)
		}
		{
			p.SetState(729)
			p.Property()
		}

		p.SetState(734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(735)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_property
	return p
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEQ, 0)
}

func (s *PropertyContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *SqlBase4GoParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBase4GoParserRULE_property)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Identifier()
	}
	{
		p.SetState(738)
		p.Match(SqlBase4GoParserEQ)
	}
	{
		p.SetState(739)
		p.Expression()
	}

	return localctx
}

// ISqlParameterDeclarationContext is an interface to support dynamic dispatch.
type ISqlParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlParameterDeclarationContext differentiates from other interfaces.
	IsSqlParameterDeclarationContext()
}

type SqlParameterDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlParameterDeclarationContext() *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_sqlParameterDeclaration
	return p
}

func (*SqlParameterDeclarationContext) IsSqlParameterDeclarationContext() {}

func NewSqlParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_sqlParameterDeclaration

	return p
}

func (s *SqlParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlParameterDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqlParameterDeclarationContext) Type_r() IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *SqlParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSqlParameterDeclaration(s)
	}
}

func (s *SqlParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSqlParameterDeclaration(s)
	}
}

func (p *SqlBase4GoParser) SqlParameterDeclaration() (localctx ISqlParameterDeclarationContext) {
	localctx = NewSqlParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBase4GoParserRULE_sqlParameterDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Identifier()
	}
	{
		p.SetState(742)
		p.type_r(0)
	}

	return localctx
}

// IRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineCharacteristicsContext differentiates from other interfaces.
	IsRoutineCharacteristicsContext()
}

type RoutineCharacteristicsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicsContext() *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_routineCharacteristics
	return p
}

func (*RoutineCharacteristicsContext) IsRoutineCharacteristicsContext() {}

func NewRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_routineCharacteristics

	return p
}

func (s *RoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicsContext) AllRoutineCharacteristic() []IRoutineCharacteristicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRoutineCharacteristicContext)(nil)).Elem())
	var tst = make([]IRoutineCharacteristicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRoutineCharacteristicContext)
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) RoutineCharacteristic(i int) IRoutineCharacteristicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineCharacteristicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicContext)
}

func (s *RoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRoutineCharacteristics(s)
	}
}

func (s *RoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRoutineCharacteristics(s)
	}
}

func (p *SqlBase4GoParser) RoutineCharacteristics() (localctx IRoutineCharacteristicsContext) {
	localctx = NewRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBase4GoParserRULE_routineCharacteristics)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserCALLED || _la == SqlBase4GoParserDETERMINISTIC || _la == SqlBase4GoParserLANGUAGE || _la == SqlBase4GoParserNOT || _la == SqlBase4GoParserRETURNS {
		{
			p.SetState(744)
			p.RoutineCharacteristic()
		}

		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineCharacteristicContext differentiates from other interfaces.
	IsRoutineCharacteristicContext()
}

type RoutineCharacteristicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicContext() *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_routineCharacteristic
	return p
}

func (*RoutineCharacteristicContext) IsRoutineCharacteristicContext() {}

func NewRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_routineCharacteristic

	return p
}

func (s *RoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLANGUAGE, 0)
}

func (s *RoutineCharacteristicContext) Language() ILanguageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILanguageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILanguageContext)
}

func (s *RoutineCharacteristicContext) Determinism() IDeterminismContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeterminismContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeterminismContext)
}

func (s *RoutineCharacteristicContext) NullCallClause() INullCallClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullCallClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullCallClauseContext)
}

func (s *RoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRoutineCharacteristic(s)
	}
}

func (s *RoutineCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRoutineCharacteristic(s)
	}
}

func (p *SqlBase4GoParser) RoutineCharacteristic() (localctx IRoutineCharacteristicContext) {
	localctx = NewRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBase4GoParserRULE_routineCharacteristic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserLANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.Match(SqlBase4GoParserLANGUAGE)
		}
		{
			p.SetState(751)
			p.Language()
		}

	case SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Determinism()
		}

	case SqlBase4GoParserCALLED, SqlBase4GoParserRETURNS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(753)
			p.NullCallClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IAlterRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterRoutineCharacteristicsContext differentiates from other interfaces.
	IsAlterRoutineCharacteristicsContext()
}

type AlterRoutineCharacteristicsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoutineCharacteristicsContext() *AlterRoutineCharacteristicsContext {
	var p = new(AlterRoutineCharacteristicsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_alterRoutineCharacteristics
	return p
}

func (*AlterRoutineCharacteristicsContext) IsAlterRoutineCharacteristicsContext() {}

func NewAlterRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineCharacteristicsContext {
	var p = new(AlterRoutineCharacteristicsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_alterRoutineCharacteristics

	return p
}

func (s *AlterRoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineCharacteristicsContext) AllAlterRoutineCharacteristic() []IAlterRoutineCharacteristicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterRoutineCharacteristicContext)(nil)).Elem())
	var tst = make([]IAlterRoutineCharacteristicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterRoutineCharacteristicContext)
		}
	}

	return tst
}

func (s *AlterRoutineCharacteristicsContext) AlterRoutineCharacteristic(i int) IAlterRoutineCharacteristicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterRoutineCharacteristicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineCharacteristicContext)
}

func (s *AlterRoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAlterRoutineCharacteristics(s)
	}
}

func (s *AlterRoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAlterRoutineCharacteristics(s)
	}
}

func (p *SqlBase4GoParser) AlterRoutineCharacteristics() (localctx IAlterRoutineCharacteristicsContext) {
	localctx = NewAlterRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBase4GoParserRULE_alterRoutineCharacteristics)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserCALLED || _la == SqlBase4GoParserRETURNS {
		{
			p.SetState(756)
			p.AlterRoutineCharacteristic()
		}

		p.SetState(761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IAlterRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterRoutineCharacteristicContext differentiates from other interfaces.
	IsAlterRoutineCharacteristicContext()
}

type AlterRoutineCharacteristicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoutineCharacteristicContext() *AlterRoutineCharacteristicContext {
	var p = new(AlterRoutineCharacteristicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_alterRoutineCharacteristic
	return p
}

func (*AlterRoutineCharacteristicContext) IsAlterRoutineCharacteristicContext() {}

func NewAlterRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineCharacteristicContext {
	var p = new(AlterRoutineCharacteristicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_alterRoutineCharacteristic

	return p
}

func (s *AlterRoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineCharacteristicContext) NullCallClause() INullCallClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullCallClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullCallClauseContext)
}

func (s *AlterRoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAlterRoutineCharacteristic(s)
	}
}

func (s *AlterRoutineCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAlterRoutineCharacteristic(s)
	}
}

func (p *SqlBase4GoParser) AlterRoutineCharacteristic() (localctx IAlterRoutineCharacteristicContext) {
	localctx = NewAlterRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBase4GoParserRULE_alterRoutineCharacteristic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.NullCallClause()
	}

	return localctx
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_routineBody
	return p
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (p *SqlBase4GoParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlBase4GoParserRULE_routineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.ReturnStatement()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *SqlBase4GoParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBase4GoParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(SqlBase4GoParserRETURN)
	}
	{
		p.SetState(767)
		p.Expression()
	}

	return localctx
}

// ILanguageContext is an interface to support dynamic dispatch.
type ILanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLanguageContext differentiates from other interfaces.
	IsLanguageContext()
}

type LanguageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageContext() *LanguageContext {
	var p = new(LanguageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_language
	return p
}

func (*LanguageContext) IsLanguageContext() {}

func NewLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageContext {
	var p = new(LanguageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_language

	return p
}

func (s *LanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSQL, 0)
}

func (s *LanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLanguage(s)
	}
}

func (s *LanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLanguage(s)
	}
}

func (p *SqlBase4GoParser) Language() (localctx ILanguageContext) {
	localctx = NewLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBase4GoParserRULE_language)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(SqlBase4GoParserSQL)
	}

	return localctx
}

// IDeterminismContext is an interface to support dynamic dispatch.
type IDeterminismContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeterminismContext differentiates from other interfaces.
	IsDeterminismContext()
}

type DeterminismContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeterminismContext() *DeterminismContext {
	var p = new(DeterminismContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_determinism
	return p
}

func (*DeterminismContext) IsDeterminismContext() {}

func NewDeterminismContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeterminismContext {
	var p = new(DeterminismContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_determinism

	return p
}

func (s *DeterminismContext) GetParser() antlr.Parser { return s.parser }

func (s *DeterminismContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDETERMINISTIC, 0)
}

func (s *DeterminismContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *DeterminismContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeterminismContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeterminismContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDeterminism(s)
	}
}

func (s *DeterminismContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDeterminism(s)
	}
}

func (p *SqlBase4GoParser) Determinism() (localctx IDeterminismContext) {
	localctx = NewDeterminismContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBase4GoParserRULE_determinism)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(774)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserDETERMINISTIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.Match(SqlBase4GoParserDETERMINISTIC)
		}

	case SqlBase4GoParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)
			p.Match(SqlBase4GoParserNOT)
		}
		{
			p.SetState(773)
			p.Match(SqlBase4GoParserDETERMINISTIC)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INullCallClauseContext is an interface to support dynamic dispatch.
type INullCallClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullCallClauseContext differentiates from other interfaces.
	IsNullCallClauseContext()
}

type NullCallClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullCallClauseContext() *NullCallClauseContext {
	var p = new(NullCallClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_nullCallClause
	return p
}

func (*NullCallClauseContext) IsNullCallClauseContext() {}

func NewNullCallClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullCallClauseContext {
	var p = new(NullCallClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_nullCallClause

	return p
}

func (s *NullCallClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NullCallClauseContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRETURNS, 0)
}

func (s *NullCallClauseContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserNULL)
}

func (s *NullCallClauseContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULL, i)
}

func (s *NullCallClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserON, 0)
}

func (s *NullCallClauseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINPUT, 0)
}

func (s *NullCallClauseContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCALLED, 0)
}

func (s *NullCallClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCallClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullCallClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNullCallClause(s)
	}
}

func (s *NullCallClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNullCallClause(s)
	}
}

func (p *SqlBase4GoParser) NullCallClause() (localctx INullCallClauseContext) {
	localctx = NewNullCallClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBase4GoParserRULE_nullCallClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(785)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserRETURNS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Match(SqlBase4GoParserRETURNS)
		}
		{
			p.SetState(777)
			p.Match(SqlBase4GoParserNULL)
		}
		{
			p.SetState(778)
			p.Match(SqlBase4GoParserON)
		}
		{
			p.SetState(779)
			p.Match(SqlBase4GoParserNULL)
		}
		{
			p.SetState(780)
			p.Match(SqlBase4GoParserINPUT)
		}

	case SqlBase4GoParserCALLED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(781)
			p.Match(SqlBase4GoParserCALLED)
		}
		{
			p.SetState(782)
			p.Match(SqlBase4GoParserON)
		}
		{
			p.SetState(783)
			p.Match(SqlBase4GoParserNULL)
		}
		{
			p.SetState(784)
			p.Match(SqlBase4GoParserINPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_queryNoWith
	return p
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryNoWithContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIMIT, 0)
}

func (s *QueryNoWithContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTEGER_VALUE, 0)
}

func (s *QueryNoWithContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (p *SqlBase4GoParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBase4GoParserRULE_queryNoWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.queryTerm(0)
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserORDER {
		{
			p.SetState(788)
			p.Match(SqlBase4GoParserORDER)
		}
		{
			p.SetState(789)
			p.Match(SqlBase4GoParserBY)
		}
		{
			p.SetState(790)
			p.SortItem()
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(791)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(792)
				p.SortItem()
			}

			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserLIMIT {
		{
			p.SetState(800)
			p.Match(SqlBase4GoParserLIMIT)
		}
		{
			p.SetState(801)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*QueryNoWithContext).limit = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserALL || _la == SqlBase4GoParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*QueryNoWithContext).limit = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_queryTerm
	return p
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyFrom(ctx *QueryTermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	*QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	*QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	p.QueryTermContext = NewEmptyQueryTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryTermContext)(nil)).Elem())
	var tst = make([]IQueryTermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryTermContext)
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryTermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXCEPT, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *SqlBase4GoParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlBase4GoParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, SqlBase4GoParserRULE_queryTerm, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(805)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(819)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_queryTerm)
				p.SetState(807)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(808)

					var _m = p.Match(SqlBase4GoParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
				}
				p.SetState(810)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBase4GoParserALL || _la == SqlBase4GoParserDISTINCT {
					{
						p.SetState(809)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(812)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_queryTerm)
				p.SetState(813)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(814)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBase4GoParserEXCEPT || _la == SqlBase4GoParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(816)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBase4GoParserALL || _la == SqlBase4GoParserDISTINCT {
					{
						p.SetState(815)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(818)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			}

		}
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
	}

	return localctx
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_queryPrimary
	return p
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyFrom(ctx *QueryPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	*QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryNoWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type QueryPrimaryDefaultContext struct {
	*QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

type TableContext struct {
	*QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTable(s)
	}
}

type InlineTableContext struct {
	*QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	p.QueryPrimaryContext = NewEmptyQueryPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *SqlBase4GoParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBase4GoParserRULE_queryPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(840)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.QuerySpecification()
		}

	case SqlBase4GoParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.Match(SqlBase4GoParserTABLE)
		}
		{
			p.SetState(826)
			p.QualifiedName()
		}

	case SqlBase4GoParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(827)
			p.Match(SqlBase4GoParserVALUES)
		}
		{
			p.SetState(828)
			p.Expression()
		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(829)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(830)
					p.Expression()
				}

			}
			p.SetState(835)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
		}

	case SqlBase4GoParserT__1:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(836)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(837)
			p.QueryNoWith()
		}
		{
			p.SetState(838)
			p.Match(SqlBase4GoParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_sortItem
	return p
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *SqlBase4GoParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlBase4GoParserRULE_sortItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Expression()
	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserASC || _la == SqlBase4GoParserDESC {
		{
			p.SetState(843)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserASC || _la == SqlBase4GoParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserNULLS {
		{
			p.SetState(846)
			p.Match(SqlBase4GoParserNULLS)
		}
		{
			p.SetState(847)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserFIRST || _la == SqlBase4GoParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *SqlBase4GoParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlBase4GoParserRULE_querySpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(SqlBase4GoParserSELECT)
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(851)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(854)
		p.SelectItem()
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(855)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(856)
				p.SelectItem()
			}

		}
		p.SetState(861)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}
	p.SetState(871)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(862)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(863)
			p.relation(0)
		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(864)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(865)
					p.relation(0)
				}

			}
			p.SetState(870)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
		}

	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(873)
			p.Match(SqlBase4GoParserWHERE)
		}
		{
			p.SetState(874)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(877)
			p.Match(SqlBase4GoParserGROUP)
		}
		{
			p.SetState(878)
			p.Match(SqlBase4GoParserBY)
		}
		{
			p.SetState(879)
			p.GroupBy()
		}

	}
	p.SetState(884)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(882)
			p.Match(SqlBase4GoParserHAVING)
		}
		{
			p.SetState(883)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem())
	var tst = make([]IGroupingElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingElementContext)
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *SqlBase4GoParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBase4GoParserRULE_groupBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(886)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(889)
		p.GroupingElement()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(890)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(891)
				p.GroupingElement()
			}

		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_groupingElement
	return p
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyFrom(ctx *GroupingElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	*GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem())
	var tst = make([]IGroupingSetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupingSetContext)
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

type SingleGroupingSetContext struct {
	*GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingSet() IGroupingSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupingSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

type CubeContext struct {
	*GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCUBE, 0)
}

func (s *CubeContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CubeContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCube(s)
	}
}

type RollupContext struct {
	*GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	p.GroupingElementContext = NewEmptyGroupingElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLLUP, 0)
}

func (s *RollupContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RollupContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (p *SqlBase4GoParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlBase4GoParserRULE_groupingElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(897)
			p.GroupingSet()
		}

	case 2:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(898)
			p.Match(SqlBase4GoParserROLLUP)
		}
		{
			p.SetState(899)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			{
				p.SetState(900)
				p.Expression()
			}
			p.SetState(905)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(901)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(902)
					p.Expression()
				}

				p.SetState(907)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(910)
			p.Match(SqlBase4GoParserT__2)
		}

	case 3:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(911)
			p.Match(SqlBase4GoParserCUBE)
		}
		{
			p.SetState(912)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			{
				p.SetState(913)
				p.Expression()
			}
			p.SetState(918)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(914)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(915)
					p.Expression()
				}

				p.SetState(920)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(923)
			p.Match(SqlBase4GoParserT__2)
		}

	case 4:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(924)
			p.Match(SqlBase4GoParserGROUPING)
		}
		{
			p.SetState(925)
			p.Match(SqlBase4GoParserSETS)
		}
		{
			p.SetState(926)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(927)
			p.GroupingSet()
		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(928)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(929)
				p.GroupingSet()
			}

			p.SetState(934)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(935)
			p.Match(SqlBase4GoParserT__2)
		}

	}

	return localctx
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_groupingSet
	return p
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *SqlBase4GoParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlBase4GoParserRULE_groupingSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(939)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			{
				p.SetState(940)
				p.Expression()
			}
			p.SetState(945)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(941)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(942)
					p.Expression()
				}

				p.SetState(947)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(950)
			p.Match(SqlBase4GoParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.Expression()
		}

	}

	return localctx
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_namedQuery
	return p
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (p *SqlBase4GoParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBase4GoParserRULE_namedQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserT__1 {
		{
			p.SetState(955)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(958)
		p.Match(SqlBase4GoParserAS)
	}
	{
		p.SetState(959)
		p.Match(SqlBase4GoParserT__1)
	}
	{
		p.SetState(960)
		p.Query()
	}
	{
		p.SetState(961)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_setQuantifier
	return p
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *SqlBase4GoParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlBase4GoParserRULE_setQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(963)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBase4GoParserALL || _la == SqlBase4GoParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *SqlBase4GoParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBase4GoParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(965)
			p.Expression()
		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			p.SetState(967)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserAS {
				{
					p.SetState(966)
					p.Match(SqlBase4GoParserAS)
				}

			}
			{
				p.SetState(969)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(972)
			p.QualifiedName()
		}
		{
			p.SetState(973)
			p.Match(SqlBase4GoParserT__0)
		}
		{
			p.SetState(974)
			p.Match(SqlBase4GoParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(976)
			p.Match(SqlBase4GoParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationContext)(nil)).Elem())
	var tst = make([]IRelationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCROSS, 0)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNATURAL, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampledRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *SqlBase4GoParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SqlBase4GoParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, SqlBase4GoParserRULE_relation, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(980)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_relation)
			p.SetState(982)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			p.SetState(996)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SqlBase4GoParserCROSS:
				{
					p.SetState(983)
					p.Match(SqlBase4GoParserCROSS)
				}
				{
					p.SetState(984)
					p.Match(SqlBase4GoParserJOIN)
				}
				{
					p.SetState(985)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case SqlBase4GoParserFULL, SqlBase4GoParserINNER, SqlBase4GoParserJOIN, SqlBase4GoParserLEFT, SqlBase4GoParserRIGHT:
				{
					p.SetState(986)
					p.JoinType()
				}
				{
					p.SetState(987)
					p.Match(SqlBase4GoParserJOIN)
				}
				{
					p.SetState(988)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(989)
					p.JoinCriteria()
				}

			case SqlBase4GoParserNATURAL:
				{
					p.SetState(991)
					p.Match(SqlBase4GoParserNATURAL)
				}
				{
					p.SetState(992)
					p.JoinType()
				}
				{
					p.SetState(993)
					p.Match(SqlBase4GoParserJOIN)
				}
				{
					p.SetState(994)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext())
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFULL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *SqlBase4GoParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBase4GoParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserINNER, SqlBase4GoParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1004)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserINNER {
			{
				p.SetState(1003)
				p.Match(SqlBase4GoParserINNER)
			}

		}

	case SqlBase4GoParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1006)
			p.Match(SqlBase4GoParserLEFT)
		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserOUTER {
			{
				p.SetState(1007)
				p.Match(SqlBase4GoParserOUTER)
			}

		}

	case SqlBase4GoParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1010)
			p.Match(SqlBase4GoParserRIGHT)
		}
		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserOUTER {
			{
				p.SetState(1011)
				p.Match(SqlBase4GoParserOUTER)
			}

		}

	case SqlBase4GoParserFULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1014)
			p.Match(SqlBase4GoParserFULL)
		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserOUTER {
			{
				p.SetState(1015)
				p.Match(SqlBase4GoParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *SqlBase4GoParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlBase4GoParserRULE_joinCriteria)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1034)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1020)
			p.Match(SqlBase4GoParserON)
		}
		{
			p.SetState(1021)
			p.booleanExpression(0)
		}

	case SqlBase4GoParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Match(SqlBase4GoParserUSING)
		}
		{
			p.SetState(1023)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1024)
			p.Identifier()
		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1025)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1026)
				p.Identifier()
			}

			p.SetState(1031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1032)
			p.Match(SqlBase4GoParserT__2)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_sampledRelation
	return p
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISampleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (p *SqlBase4GoParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBase4GoParserRULE_sampledRelation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.AliasedRelation()
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1037)
			p.Match(SqlBase4GoParserTABLESAMPLE)
		}
		{
			p.SetState(1038)
			p.SampleType()
		}
		{
			p.SetState(1039)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1040)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(1041)
			p.Match(SqlBase4GoParserT__2)
		}

	}

	return localctx
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_sampleType
	return p
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBERNOULLI, 0)
}

func (s *SampleTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSYSTEM, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (p *SqlBase4GoParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBase4GoParserRULE_sampleType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBase4GoParserBERNOULLI || _la == SqlBase4GoParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnAliasesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *SqlBase4GoParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlBase4GoParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.RelationPrimary()
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserAS {
			{
				p.SetState(1048)
				p.Match(SqlBase4GoParserAS)
			}

		}
		{
			p.SetState(1051)
			p.Identifier()
		}
		p.SetState(1053)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1052)
				p.ColumnAliases()
			}

		}

	}

	return localctx
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_columnAliases
	return p
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *SqlBase4GoParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBase4GoParserRULE_columnAliases)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(SqlBase4GoParserT__1)
	}
	{
		p.SetState(1058)
		p.Identifier()
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserT__3 {
		{
			p.SetState(1059)
			p.Match(SqlBase4GoParserT__3)
		}
		{
			p.SetState(1060)
			p.Identifier()
		}

		p.SetState(1065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1066)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	*RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

type ParenthesizedRelationContext struct {
	*RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

type UnnestContext struct {
	*RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUnnest(s)
	}
}

type LateralContext struct {
	*RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLATERAL, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLateral(s)
	}
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *SqlBase4GoParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBase4GoParserRULE_relationPrimary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1068)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1069)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1070)
			p.Query()
		}
		{
			p.SetState(1071)
			p.Match(SqlBase4GoParserT__2)
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1073)
			p.Match(SqlBase4GoParserUNNEST)
		}
		{
			p.SetState(1074)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1075)
			p.Expression()
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1076)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1077)
				p.Expression()
			}

			p.SetState(1082)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1083)
			p.Match(SqlBase4GoParserT__2)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1084)
				p.Match(SqlBase4GoParserWITH)
			}
			{
				p.SetState(1085)
				p.Match(SqlBase4GoParserORDINALITY)
			}

		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1088)
			p.Match(SqlBase4GoParserLATERAL)
		}
		{
			p.SetState(1089)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1090)
			p.Query()
		}
		{
			p.SetState(1091)
			p.Match(SqlBase4GoParserT__2)
		}

	case 5:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1093)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1094)
			p.relation(0)
		}
		{
			p.SetState(1095)
			p.Match(SqlBase4GoParserT__2)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SqlBase4GoParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBase4GoParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	*BooleanExpressionContext
	_valueExpression IValueExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *SqlBase4GoParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBase4GoParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 82
	p.EnterRecursionRule(localctx, 82, SqlBase4GoParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserT__1, SqlBase4GoParserT__4, SqlBase4GoParserMyString, SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCASE, SqlBase4GoParserCAST, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_DATE, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserCURRENT_TIME, SqlBase4GoParserCURRENT_TIMESTAMP, SqlBase4GoParserCURRENT_USER, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXISTS, SqlBase4GoParserEXPLAIN, SqlBase4GoParserEXTRACT, SqlBase4GoParserFALSE, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserGROUPING, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOCALTIME, SqlBase4GoParserLOCALTIMESTAMP, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNORMALIZE, SqlBase4GoParserNULL, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRUE, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserPLUS, SqlBase4GoParserMINUS, SqlBase4GoParserBINARY_LITERAL, SqlBase4GoParserINTEGER_VALUE, SqlBase4GoParserDECIMAL_VALUE, SqlBase4GoParserDOUBLE_VALUE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER, SqlBase4GoParserDOUBLE_PRECISION:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1102)

			var _x = p.valueExpression(0)

			localctx.(*PredicatedContext)._valueExpression = _x
		}
		p.SetState(1104)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1103)
				p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
			}

		}

	case SqlBase4GoParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1106)
			p.Match(SqlBase4GoParserNOT)
		}
		{
			p.SetState(1107)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1116)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_booleanExpression)
				p.SetState(1110)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1111)

					var _m = p.Match(SqlBase4GoParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(1112)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_booleanExpression)
				p.SetState(1113)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1114)

					var _m = p.Match(SqlBase4GoParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(1115)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLike(s)
	}
}

type InSubqueryContext struct {
	*PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBetween(s)
	}
}

type QuantifiedComparisonContext struct {
	*PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (p *SqlBase4GoParser) Predicate(value ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 84, SqlBase4GoParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1121)
			p.ComparisonOperator()
		}
		{
			p.SetState(1122)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1124)
			p.ComparisonOperator()
		}
		{
			p.SetState(1125)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(1126)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1127)
			p.Query()
		}
		{
			p.SetState(1128)
			p.Match(SqlBase4GoParserT__2)
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1130)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1133)
			p.Match(SqlBase4GoParserBETWEEN)
		}
		{
			p.SetState(1134)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(1135)
			p.Match(SqlBase4GoParserAND)
		}
		{
			p.SetState(1136)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1138)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1141)
			p.Match(SqlBase4GoParserIN)
		}
		{
			p.SetState(1142)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1143)
			p.Expression()
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1144)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1145)
				p.Expression()
			}

			p.SetState(1150)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1151)
			p.Match(SqlBase4GoParserT__2)
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1153)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1156)
			p.Match(SqlBase4GoParserIN)
		}
		{
			p.SetState(1157)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1158)
			p.Query()
		}
		{
			p.SetState(1159)
			p.Match(SqlBase4GoParserT__2)
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1161)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1164)
			p.Match(SqlBase4GoParserLIKE)
		}
		{
			p.SetState(1165)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1166)
				p.Match(SqlBase4GoParserESCAPE)
			}
			{
				p.SetState(1167)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1170)
			p.Match(SqlBase4GoParserIS)
		}
		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1171)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1174)
			p.Match(SqlBase4GoParserNULL)
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1175)
			p.Match(SqlBase4GoParserIS)
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserNOT {
			{
				p.SetState(1176)
				p.Match(SqlBase4GoParserNOT)
			}

		}
		{
			p.SetState(1179)
			p.Match(SqlBase4GoParserDISTINCT)
		}
		{
			p.SetState(1180)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(1181)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *SqlBase4GoParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBase4GoParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, SqlBase4GoParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserT__1, SqlBase4GoParserT__4, SqlBase4GoParserMyString, SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCASE, SqlBase4GoParserCAST, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_DATE, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserCURRENT_TIME, SqlBase4GoParserCURRENT_TIMESTAMP, SqlBase4GoParserCURRENT_USER, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXISTS, SqlBase4GoParserEXPLAIN, SqlBase4GoParserEXTRACT, SqlBase4GoParserFALSE, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserGROUPING, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOCALTIME, SqlBase4GoParserLOCALTIMESTAMP, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNORMALIZE, SqlBase4GoParserNULL, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRUE, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserBINARY_LITERAL, SqlBase4GoParserINTEGER_VALUE, SqlBase4GoParserDECIMAL_VALUE, SqlBase4GoParserDOUBLE_VALUE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER, SqlBase4GoParserDOUBLE_PRECISION:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1185)
			p.primaryExpression(0)
		}

	case SqlBase4GoParserPLUS, SqlBase4GoParserMINUS:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1186)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserPLUS || _la == SqlBase4GoParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1187)
			p.valueExpression(4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1202)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_valueExpression)
				p.SetState(1190)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1191)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(SqlBase4GoParserASTERISK-213))|(1<<(SqlBase4GoParserSLASH-213))|(1<<(SqlBase4GoParserPERCENT-213)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1192)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_valueExpression)
				p.SetState(1193)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1194)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBase4GoParserPLUS || _la == SqlBase4GoParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1195)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_valueExpression)
				p.SetState(1196)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1197)
					p.Match(SqlBase4GoParserCONCAT)
				}
				{
					p.SetState(1198)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_valueExpression)
				p.SetState(1199)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1200)
					p.Match(SqlBase4GoParserAT)
				}
				{
					p.SetState(1201)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDereference(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *TypeConstructorContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDOUBLE_PRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	*PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

type SubstringContext struct {
	*PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSubstring(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAS, 0)
}

func (s *CastContext) Type_r() IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCast(s)
	}
}

type LambdaContext struct {
	*PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitLambda(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ParameterContext struct {
	*PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitParameter(s)
	}
}

type NormalizeContext struct {
	*PrimaryExpressionContext
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNORMALIZE, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) NormalForm() INormalFormContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalFormContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNormalize(s)
	}
}

type IntervalLiteralContext struct {
	*PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type NumericLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type NullLiteralContext struct {
	*PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type RowConstructorContext struct {
	*PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type SubqueryExpressionContext struct {
	*PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type BinaryLiteralContext struct {
	*PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

type CurrentUserContext struct {
	*PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

type ExtractContext struct {
	*PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExtract(s)
	}
}

type StringLiteralContext struct {
	*PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) NullTreatment() INullTreatmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullTreatmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type ExistsContext struct {
	*PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExists(s)
	}
}

type PositionContext struct {
	*PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitPosition(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type GroupingOperationContext struct {
	*PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (p *SqlBase4GoParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBase4GoParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 88
	p.EnterRecursionRule(localctx, 88, SqlBase4GoParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1208)
			p.Match(SqlBase4GoParserNULL)
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1209)
			p.Interval()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1210)
			p.Identifier()
		}
		{
			p.SetState(1211)
			p.Match(SqlBase4GoParserMyString)
		}

	case 4:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1213)
			p.Match(SqlBase4GoParserDOUBLE_PRECISION)
		}
		{
			p.SetState(1214)
			p.Match(SqlBase4GoParserMyString)
		}

	case 5:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1215)
			p.Number()
		}

	case 6:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1216)
			p.BooleanValue()
		}

	case 7:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1217)
			p.Match(SqlBase4GoParserMyString)
		}

	case 8:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1218)
			p.Match(SqlBase4GoParserBINARY_LITERAL)
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1219)
			p.Match(SqlBase4GoParserT__4)
		}

	case 10:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1220)
			p.Match(SqlBase4GoParserPOSITION)
		}
		{
			p.SetState(1221)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1222)
			p.valueExpression(0)
		}
		{
			p.SetState(1223)
			p.Match(SqlBase4GoParserIN)
		}
		{
			p.SetState(1224)
			p.valueExpression(0)
		}
		{
			p.SetState(1225)
			p.Match(SqlBase4GoParserT__2)
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1227)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1228)
			p.Expression()
		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1229)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1230)
				p.Expression()
			}

			p.SetState(1233)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1235)
			p.Match(SqlBase4GoParserT__2)
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1237)
			p.Match(SqlBase4GoParserROW)
		}
		{
			p.SetState(1238)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1239)
			p.Expression()
		}
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1240)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1241)
				p.Expression()
			}

			p.SetState(1246)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1247)
			p.Match(SqlBase4GoParserT__2)
		}

	case 13:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1249)
			p.QualifiedName()
		}
		{
			p.SetState(1250)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1251)
			p.Match(SqlBase4GoParserASTERISK)
		}
		{
			p.SetState(1252)
			p.Match(SqlBase4GoParserT__2)
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1253)
				p.Filter()
			}

		}
		p.SetState(1257)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1256)
				p.Over()
			}

		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1259)
			p.QualifiedName()
		}
		{
			p.SetState(1260)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTINCT-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			p.SetState(1262)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1261)
					p.SetQuantifier()
				}

			}
			{
				p.SetState(1264)
				p.Expression()
			}
			p.SetState(1269)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1265)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1266)
					p.Expression()
				}

				p.SetState(1271)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserORDER {
			{
				p.SetState(1274)
				p.Match(SqlBase4GoParserORDER)
			}
			{
				p.SetState(1275)
				p.Match(SqlBase4GoParserBY)
			}
			{
				p.SetState(1276)
				p.SortItem()
			}
			p.SetState(1281)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1277)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1278)
					p.SortItem()
				}

				p.SetState(1283)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1286)
			p.Match(SqlBase4GoParserT__2)
		}
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1287)
				p.Filter()
			}

		}
		p.SetState(1294)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
			p.SetState(1291)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBase4GoParserIGNORE || _la == SqlBase4GoParserRESPECT {
				{
					p.SetState(1290)
					p.NullTreatment()
				}

			}
			{
				p.SetState(1293)
				p.Over()
			}

		}

	case 15:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1296)
			p.Identifier()
		}
		{
			p.SetState(1297)
			p.Match(SqlBase4GoParserT__5)
		}
		{
			p.SetState(1298)
			p.Expression()
		}

	case 16:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1300)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(SqlBase4GoParserADD-11))|(1<<(SqlBase4GoParserADMIN-11))|(1<<(SqlBase4GoParserALL-11))|(1<<(SqlBase4GoParserANALYZE-11))|(1<<(SqlBase4GoParserANY-11))|(1<<(SqlBase4GoParserARRAY-11))|(1<<(SqlBase4GoParserASC-11))|(1<<(SqlBase4GoParserAT-11))|(1<<(SqlBase4GoParserBERNOULLI-11))|(1<<(SqlBase4GoParserCALL-11))|(1<<(SqlBase4GoParserCALLED-11))|(1<<(SqlBase4GoParserCASCADE-11))|(1<<(SqlBase4GoParserCATALOGS-11))|(1<<(SqlBase4GoParserCOLUMN-11))|(1<<(SqlBase4GoParserCOLUMNS-11))|(1<<(SqlBase4GoParserCOMMENT-11))|(1<<(SqlBase4GoParserCOMMIT-11))|(1<<(SqlBase4GoParserCOMMITTED-11))|(1<<(SqlBase4GoParserCURRENT-11))|(1<<(SqlBase4GoParserCURRENT_ROLE-11)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SqlBase4GoParserDATA-46))|(1<<(SqlBase4GoParserDATE-46))|(1<<(SqlBase4GoParserDAY-46))|(1<<(SqlBase4GoParserDESC-46))|(1<<(SqlBase4GoParserDETERMINISTIC-46))|(1<<(SqlBase4GoParserDISTRIBUTED-46))|(1<<(SqlBase4GoParserEXCLUDING-46))|(1<<(SqlBase4GoParserEXPLAIN-46))|(1<<(SqlBase4GoParserFILTER-46))|(1<<(SqlBase4GoParserFIRST-46))|(1<<(SqlBase4GoParserFOLLOWING-46))|(1<<(SqlBase4GoParserFORMAT-46))|(1<<(SqlBase4GoParserFUNCTION-46))|(1<<(SqlBase4GoParserFUNCTIONS-46))|(1<<(SqlBase4GoParserGRANT-46))|(1<<(SqlBase4GoParserGRANTED-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SqlBase4GoParserGRANTS-78))|(1<<(SqlBase4GoParserGRAPHVIZ-78))|(1<<(SqlBase4GoParserHOUR-78))|(1<<(SqlBase4GoParserIF-78))|(1<<(SqlBase4GoParserIGNORE-78))|(1<<(SqlBase4GoParserINCLUDING-78))|(1<<(SqlBase4GoParserINPUT-78))|(1<<(SqlBase4GoParserINTERVAL-78))|(1<<(SqlBase4GoParserIO-78))|(1<<(SqlBase4GoParserISOLATION-78))|(1<<(SqlBase4GoParserJSON-78))|(1<<(SqlBase4GoParserLANGUAGE-78))|(1<<(SqlBase4GoParserLAST-78))|(1<<(SqlBase4GoParserLATERAL-78))|(1<<(SqlBase4GoParserLEVEL-78))|(1<<(SqlBase4GoParserLIMIT-78))|(1<<(SqlBase4GoParserLOGICAL-78))|(1<<(SqlBase4GoParserMAP-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBase4GoParserMINUTE-110))|(1<<(SqlBase4GoParserMONTH-110))|(1<<(SqlBase4GoParserNFC-110))|(1<<(SqlBase4GoParserNFD-110))|(1<<(SqlBase4GoParserNFKC-110))|(1<<(SqlBase4GoParserNFKD-110))|(1<<(SqlBase4GoParserNO-110))|(1<<(SqlBase4GoParserNONE-110))|(1<<(SqlBase4GoParserNULLIF-110))|(1<<(SqlBase4GoParserNULLS-110))|(1<<(SqlBase4GoParserONLY-110))|(1<<(SqlBase4GoParserOPTION-110))|(1<<(SqlBase4GoParserORDINALITY-110))|(1<<(SqlBase4GoParserOUTPUT-110))|(1<<(SqlBase4GoParserOVER-110))|(1<<(SqlBase4GoParserPARTITION-110))|(1<<(SqlBase4GoParserPARTITIONS-110))|(1<<(SqlBase4GoParserPOSITION-110))|(1<<(SqlBase4GoParserPRECEDING-110))|(1<<(SqlBase4GoParserPRIVILEGES-110))|(1<<(SqlBase4GoParserPROPERTIES-110))|(1<<(SqlBase4GoParserRANGE-110))|(1<<(SqlBase4GoParserREAD-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBase4GoParserRENAME-143))|(1<<(SqlBase4GoParserREPEATABLE-143))|(1<<(SqlBase4GoParserREPLACE-143))|(1<<(SqlBase4GoParserRESET-143))|(1<<(SqlBase4GoParserRESPECT-143))|(1<<(SqlBase4GoParserRESTRICT-143))|(1<<(SqlBase4GoParserRETURN-143))|(1<<(SqlBase4GoParserRETURNS-143))|(1<<(SqlBase4GoParserREVOKE-143))|(1<<(SqlBase4GoParserROLE-143))|(1<<(SqlBase4GoParserROLES-143))|(1<<(SqlBase4GoParserROLLBACK-143))|(1<<(SqlBase4GoParserROW-143))|(1<<(SqlBase4GoParserROWS-143))|(1<<(SqlBase4GoParserSCHEMA-143))|(1<<(SqlBase4GoParserSCHEMAS-143))|(1<<(SqlBase4GoParserSECOND-143))|(1<<(SqlBase4GoParserSERIALIZABLE-143))|(1<<(SqlBase4GoParserSESSION-143))|(1<<(SqlBase4GoParserSET-143))|(1<<(SqlBase4GoParserSETS-143))|(1<<(SqlBase4GoParserSHOW-143))|(1<<(SqlBase4GoParserSOME-143))|(1<<(SqlBase4GoParserSQL-143))|(1<<(SqlBase4GoParserSTART-143))|(1<<(SqlBase4GoParserSTATS-143))|(1<<(SqlBase4GoParserSUBSTRING-143))|(1<<(SqlBase4GoParserSYSTEM-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBase4GoParserTABLES-175))|(1<<(SqlBase4GoParserTABLESAMPLE-175))|(1<<(SqlBase4GoParserTEXT-175))|(1<<(SqlBase4GoParserTIME-175))|(1<<(SqlBase4GoParserTIMESTAMP-175))|(1<<(SqlBase4GoParserTO-175))|(1<<(SqlBase4GoParserTRANSACTION-175))|(1<<(SqlBase4GoParserTRY_CAST-175))|(1<<(SqlBase4GoParserTYPE-175))|(1<<(SqlBase4GoParserUNBOUNDED-175))|(1<<(SqlBase4GoParserUNCOMMITTED-175))|(1<<(SqlBase4GoParserUSE-175))|(1<<(SqlBase4GoParserUSER-175))|(1<<(SqlBase4GoParserVALIDATE-175))|(1<<(SqlBase4GoParserVERBOSE-175))|(1<<(SqlBase4GoParserVIEW-175))|(1<<(SqlBase4GoParserWORK-175))|(1<<(SqlBase4GoParserWRITE-175))|(1<<(SqlBase4GoParserYEAR-175))|(1<<(SqlBase4GoParserZONE-175)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SqlBase4GoParserIDENTIFIER-223))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-223))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-223))|(1<<(SqlBase4GoParserBACKQUOTED_IDENTIFIER-223)))) != 0) {
			{
				p.SetState(1301)
				p.Identifier()
			}
			p.SetState(1306)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1302)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1303)
					p.Identifier()
				}

				p.SetState(1308)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1311)
			p.Match(SqlBase4GoParserT__2)
		}
		{
			p.SetState(1312)
			p.Match(SqlBase4GoParserT__5)
		}
		{
			p.SetState(1313)
			p.Expression()
		}

	case 17:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1314)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1315)
			p.Query()
		}
		{
			p.SetState(1316)
			p.Match(SqlBase4GoParserT__2)
		}

	case 18:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1318)
			p.Match(SqlBase4GoParserEXISTS)
		}
		{
			p.SetState(1319)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1320)
			p.Query()
		}
		{
			p.SetState(1321)
			p.Match(SqlBase4GoParserT__2)
		}

	case 19:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1323)
			p.Match(SqlBase4GoParserCASE)
		}
		{
			p.SetState(1324)
			p.valueExpression(0)
		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBase4GoParserWHEN {
			{
				p.SetState(1325)
				p.WhenClause()
			}

			p.SetState(1328)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserELSE {
			{
				p.SetState(1330)
				p.Match(SqlBase4GoParserELSE)
			}
			{
				p.SetState(1331)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1334)
			p.Match(SqlBase4GoParserEND)
		}

	case 20:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1336)
			p.Match(SqlBase4GoParserCASE)
		}
		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBase4GoParserWHEN {
			{
				p.SetState(1337)
				p.WhenClause()
			}

			p.SetState(1340)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserELSE {
			{
				p.SetState(1342)
				p.Match(SqlBase4GoParserELSE)
			}
			{
				p.SetState(1343)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1346)
			p.Match(SqlBase4GoParserEND)
		}

	case 21:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1348)
			p.Match(SqlBase4GoParserCAST)
		}
		{
			p.SetState(1349)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1350)
			p.Expression()
		}
		{
			p.SetState(1351)
			p.Match(SqlBase4GoParserAS)
		}
		{
			p.SetState(1352)
			p.type_r(0)
		}
		{
			p.SetState(1353)
			p.Match(SqlBase4GoParserT__2)
		}

	case 22:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1355)
			p.Match(SqlBase4GoParserTRY_CAST)
		}
		{
			p.SetState(1356)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1357)
			p.Expression()
		}
		{
			p.SetState(1358)
			p.Match(SqlBase4GoParserAS)
		}
		{
			p.SetState(1359)
			p.type_r(0)
		}
		{
			p.SetState(1360)
			p.Match(SqlBase4GoParserT__2)
		}

	case 23:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1362)
			p.Match(SqlBase4GoParserARRAY)
		}
		{
			p.SetState(1363)
			p.Match(SqlBase4GoParserT__6)
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SqlBase4GoParserT__1)|(1<<SqlBase4GoParserT__4)|(1<<SqlBase4GoParserMyString)|(1<<SqlBase4GoParserADD)|(1<<SqlBase4GoParserADMIN)|(1<<SqlBase4GoParserALL)|(1<<SqlBase4GoParserANALYZE)|(1<<SqlBase4GoParserANY)|(1<<SqlBase4GoParserARRAY)|(1<<SqlBase4GoParserASC)|(1<<SqlBase4GoParserAT)|(1<<SqlBase4GoParserBERNOULLI)|(1<<SqlBase4GoParserCALL)|(1<<SqlBase4GoParserCALLED)|(1<<SqlBase4GoParserCASCADE)|(1<<SqlBase4GoParserCASE)|(1<<SqlBase4GoParserCAST)|(1<<SqlBase4GoParserCATALOGS)|(1<<SqlBase4GoParserCOLUMN))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SqlBase4GoParserCOLUMNS-32))|(1<<(SqlBase4GoParserCOMMENT-32))|(1<<(SqlBase4GoParserCOMMIT-32))|(1<<(SqlBase4GoParserCOMMITTED-32))|(1<<(SqlBase4GoParserCURRENT-32))|(1<<(SqlBase4GoParserCURRENT_DATE-32))|(1<<(SqlBase4GoParserCURRENT_ROLE-32))|(1<<(SqlBase4GoParserCURRENT_TIME-32))|(1<<(SqlBase4GoParserCURRENT_TIMESTAMP-32))|(1<<(SqlBase4GoParserCURRENT_USER-32))|(1<<(SqlBase4GoParserDATA-32))|(1<<(SqlBase4GoParserDATE-32))|(1<<(SqlBase4GoParserDAY-32))|(1<<(SqlBase4GoParserDESC-32))|(1<<(SqlBase4GoParserDETERMINISTIC-32))|(1<<(SqlBase4GoParserDISTRIBUTED-32))|(1<<(SqlBase4GoParserEXCLUDING-32))|(1<<(SqlBase4GoParserEXISTS-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(SqlBase4GoParserEXPLAIN-64))|(1<<(SqlBase4GoParserEXTRACT-64))|(1<<(SqlBase4GoParserFALSE-64))|(1<<(SqlBase4GoParserFILTER-64))|(1<<(SqlBase4GoParserFIRST-64))|(1<<(SqlBase4GoParserFOLLOWING-64))|(1<<(SqlBase4GoParserFORMAT-64))|(1<<(SqlBase4GoParserFUNCTION-64))|(1<<(SqlBase4GoParserFUNCTIONS-64))|(1<<(SqlBase4GoParserGRANT-64))|(1<<(SqlBase4GoParserGRANTED-64))|(1<<(SqlBase4GoParserGRANTS-64))|(1<<(SqlBase4GoParserGRAPHVIZ-64))|(1<<(SqlBase4GoParserGROUPING-64))|(1<<(SqlBase4GoParserHOUR-64))|(1<<(SqlBase4GoParserIF-64))|(1<<(SqlBase4GoParserIGNORE-64))|(1<<(SqlBase4GoParserINCLUDING-64))|(1<<(SqlBase4GoParserINPUT-64))|(1<<(SqlBase4GoParserINTERVAL-64))|(1<<(SqlBase4GoParserIO-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(SqlBase4GoParserISOLATION-96))|(1<<(SqlBase4GoParserJSON-96))|(1<<(SqlBase4GoParserLANGUAGE-96))|(1<<(SqlBase4GoParserLAST-96))|(1<<(SqlBase4GoParserLATERAL-96))|(1<<(SqlBase4GoParserLEVEL-96))|(1<<(SqlBase4GoParserLIMIT-96))|(1<<(SqlBase4GoParserLOCALTIME-96))|(1<<(SqlBase4GoParserLOCALTIMESTAMP-96))|(1<<(SqlBase4GoParserLOGICAL-96))|(1<<(SqlBase4GoParserMAP-96))|(1<<(SqlBase4GoParserMINUTE-96))|(1<<(SqlBase4GoParserMONTH-96))|(1<<(SqlBase4GoParserNFC-96))|(1<<(SqlBase4GoParserNFD-96))|(1<<(SqlBase4GoParserNFKC-96))|(1<<(SqlBase4GoParserNFKD-96))|(1<<(SqlBase4GoParserNO-96))|(1<<(SqlBase4GoParserNONE-96))|(1<<(SqlBase4GoParserNORMALIZE-96))|(1<<(SqlBase4GoParserNOT-96))|(1<<(SqlBase4GoParserNULL-96))|(1<<(SqlBase4GoParserNULLIF-96))|(1<<(SqlBase4GoParserNULLS-96))|(1<<(SqlBase4GoParserONLY-96))|(1<<(SqlBase4GoParserOPTION-96)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SqlBase4GoParserORDINALITY-129))|(1<<(SqlBase4GoParserOUTPUT-129))|(1<<(SqlBase4GoParserOVER-129))|(1<<(SqlBase4GoParserPARTITION-129))|(1<<(SqlBase4GoParserPARTITIONS-129))|(1<<(SqlBase4GoParserPOSITION-129))|(1<<(SqlBase4GoParserPRECEDING-129))|(1<<(SqlBase4GoParserPRIVILEGES-129))|(1<<(SqlBase4GoParserPROPERTIES-129))|(1<<(SqlBase4GoParserRANGE-129))|(1<<(SqlBase4GoParserREAD-129))|(1<<(SqlBase4GoParserRENAME-129))|(1<<(SqlBase4GoParserREPEATABLE-129))|(1<<(SqlBase4GoParserREPLACE-129))|(1<<(SqlBase4GoParserRESET-129))|(1<<(SqlBase4GoParserRESPECT-129))|(1<<(SqlBase4GoParserRESTRICT-129))|(1<<(SqlBase4GoParserRETURN-129))|(1<<(SqlBase4GoParserRETURNS-129))|(1<<(SqlBase4GoParserREVOKE-129))|(1<<(SqlBase4GoParserROLE-129))|(1<<(SqlBase4GoParserROLES-129))|(1<<(SqlBase4GoParserROLLBACK-129))|(1<<(SqlBase4GoParserROW-129))|(1<<(SqlBase4GoParserROWS-129))|(1<<(SqlBase4GoParserSCHEMA-129))|(1<<(SqlBase4GoParserSCHEMAS-129)))) != 0) || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SqlBase4GoParserSECOND-161))|(1<<(SqlBase4GoParserSERIALIZABLE-161))|(1<<(SqlBase4GoParserSESSION-161))|(1<<(SqlBase4GoParserSET-161))|(1<<(SqlBase4GoParserSETS-161))|(1<<(SqlBase4GoParserSHOW-161))|(1<<(SqlBase4GoParserSOME-161))|(1<<(SqlBase4GoParserSQL-161))|(1<<(SqlBase4GoParserSTART-161))|(1<<(SqlBase4GoParserSTATS-161))|(1<<(SqlBase4GoParserSUBSTRING-161))|(1<<(SqlBase4GoParserSYSTEM-161))|(1<<(SqlBase4GoParserTABLES-161))|(1<<(SqlBase4GoParserTABLESAMPLE-161))|(1<<(SqlBase4GoParserTEXT-161))|(1<<(SqlBase4GoParserTIME-161))|(1<<(SqlBase4GoParserTIMESTAMP-161))|(1<<(SqlBase4GoParserTO-161))|(1<<(SqlBase4GoParserTRANSACTION-161))|(1<<(SqlBase4GoParserTRUE-161))|(1<<(SqlBase4GoParserTRY_CAST-161))|(1<<(SqlBase4GoParserTYPE-161))|(1<<(SqlBase4GoParserUNBOUNDED-161))|(1<<(SqlBase4GoParserUNCOMMITTED-161))|(1<<(SqlBase4GoParserUSE-161))|(1<<(SqlBase4GoParserUSER-161)))) != 0) || (((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(SqlBase4GoParserVALIDATE-194))|(1<<(SqlBase4GoParserVERBOSE-194))|(1<<(SqlBase4GoParserVIEW-194))|(1<<(SqlBase4GoParserWORK-194))|(1<<(SqlBase4GoParserWRITE-194))|(1<<(SqlBase4GoParserYEAR-194))|(1<<(SqlBase4GoParserZONE-194))|(1<<(SqlBase4GoParserPLUS-194))|(1<<(SqlBase4GoParserMINUS-194))|(1<<(SqlBase4GoParserBINARY_LITERAL-194))|(1<<(SqlBase4GoParserINTEGER_VALUE-194))|(1<<(SqlBase4GoParserDECIMAL_VALUE-194))|(1<<(SqlBase4GoParserDOUBLE_VALUE-194))|(1<<(SqlBase4GoParserIDENTIFIER-194))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-194))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-194)))) != 0) || _la == SqlBase4GoParserBACKQUOTED_IDENTIFIER || _la == SqlBase4GoParserDOUBLE_PRECISION {
			{
				p.SetState(1364)
				p.Expression()
			}
			p.SetState(1369)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1365)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1366)
					p.Expression()
				}

				p.SetState(1371)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1374)
			p.Match(SqlBase4GoParserT__7)
		}

	case 24:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1375)
			p.Identifier()
		}

	case 25:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1376)

			var _m = p.Match(SqlBase4GoParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1377)

			var _m = p.Match(SqlBase4GoParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1381)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1378)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(1379)

				var _m = p.Match(SqlBase4GoParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1380)
				p.Match(SqlBase4GoParserT__2)
			}

		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1383)

			var _m = p.Match(SqlBase4GoParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1387)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1384)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(1385)

				var _m = p.Match(SqlBase4GoParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1386)
				p.Match(SqlBase4GoParserT__2)
			}

		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1389)

			var _m = p.Match(SqlBase4GoParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1390)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(1391)

				var _m = p.Match(SqlBase4GoParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1392)
				p.Match(SqlBase4GoParserT__2)
			}

		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1395)

			var _m = p.Match(SqlBase4GoParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1396)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(1397)

				var _m = p.Match(SqlBase4GoParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
			}
			{
				p.SetState(1398)
				p.Match(SqlBase4GoParserT__2)
			}

		}

	case 30:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1401)

			var _m = p.Match(SqlBase4GoParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
		}

	case 31:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1402)
			p.Match(SqlBase4GoParserSUBSTRING)
		}
		{
			p.SetState(1403)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1404)
			p.valueExpression(0)
		}
		{
			p.SetState(1405)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(1406)
			p.valueExpression(0)
		}
		p.SetState(1409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserFOR {
			{
				p.SetState(1407)
				p.Match(SqlBase4GoParserFOR)
			}
			{
				p.SetState(1408)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(1411)
			p.Match(SqlBase4GoParserT__2)
		}

	case 32:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1413)
			p.Match(SqlBase4GoParserNORMALIZE)
		}
		{
			p.SetState(1414)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1415)
			p.valueExpression(0)
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1416)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1417)
				p.NormalForm()
			}

		}
		{
			p.SetState(1420)
			p.Match(SqlBase4GoParserT__2)
		}

	case 33:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1422)
			p.Match(SqlBase4GoParserEXTRACT)
		}
		{
			p.SetState(1423)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1424)
			p.Identifier()
		}
		{
			p.SetState(1425)
			p.Match(SqlBase4GoParserFROM)
		}
		{
			p.SetState(1426)
			p.valueExpression(0)
		}
		{
			p.SetState(1427)
			p.Match(SqlBase4GoParserT__2)
		}

	case 34:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1429)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1430)
			p.Expression()
		}
		{
			p.SetState(1431)
			p.Match(SqlBase4GoParserT__2)
		}

	case 35:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1433)
			p.Match(SqlBase4GoParserGROUPING)
		}
		{
			p.SetState(1434)
			p.Match(SqlBase4GoParserT__1)
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(SqlBase4GoParserADD-11))|(1<<(SqlBase4GoParserADMIN-11))|(1<<(SqlBase4GoParserALL-11))|(1<<(SqlBase4GoParserANALYZE-11))|(1<<(SqlBase4GoParserANY-11))|(1<<(SqlBase4GoParserARRAY-11))|(1<<(SqlBase4GoParserASC-11))|(1<<(SqlBase4GoParserAT-11))|(1<<(SqlBase4GoParserBERNOULLI-11))|(1<<(SqlBase4GoParserCALL-11))|(1<<(SqlBase4GoParserCALLED-11))|(1<<(SqlBase4GoParserCASCADE-11))|(1<<(SqlBase4GoParserCATALOGS-11))|(1<<(SqlBase4GoParserCOLUMN-11))|(1<<(SqlBase4GoParserCOLUMNS-11))|(1<<(SqlBase4GoParserCOMMENT-11))|(1<<(SqlBase4GoParserCOMMIT-11))|(1<<(SqlBase4GoParserCOMMITTED-11))|(1<<(SqlBase4GoParserCURRENT-11))|(1<<(SqlBase4GoParserCURRENT_ROLE-11)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SqlBase4GoParserDATA-46))|(1<<(SqlBase4GoParserDATE-46))|(1<<(SqlBase4GoParserDAY-46))|(1<<(SqlBase4GoParserDESC-46))|(1<<(SqlBase4GoParserDETERMINISTIC-46))|(1<<(SqlBase4GoParserDISTRIBUTED-46))|(1<<(SqlBase4GoParserEXCLUDING-46))|(1<<(SqlBase4GoParserEXPLAIN-46))|(1<<(SqlBase4GoParserFILTER-46))|(1<<(SqlBase4GoParserFIRST-46))|(1<<(SqlBase4GoParserFOLLOWING-46))|(1<<(SqlBase4GoParserFORMAT-46))|(1<<(SqlBase4GoParserFUNCTION-46))|(1<<(SqlBase4GoParserFUNCTIONS-46))|(1<<(SqlBase4GoParserGRANT-46))|(1<<(SqlBase4GoParserGRANTED-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SqlBase4GoParserGRANTS-78))|(1<<(SqlBase4GoParserGRAPHVIZ-78))|(1<<(SqlBase4GoParserHOUR-78))|(1<<(SqlBase4GoParserIF-78))|(1<<(SqlBase4GoParserIGNORE-78))|(1<<(SqlBase4GoParserINCLUDING-78))|(1<<(SqlBase4GoParserINPUT-78))|(1<<(SqlBase4GoParserINTERVAL-78))|(1<<(SqlBase4GoParserIO-78))|(1<<(SqlBase4GoParserISOLATION-78))|(1<<(SqlBase4GoParserJSON-78))|(1<<(SqlBase4GoParserLANGUAGE-78))|(1<<(SqlBase4GoParserLAST-78))|(1<<(SqlBase4GoParserLATERAL-78))|(1<<(SqlBase4GoParserLEVEL-78))|(1<<(SqlBase4GoParserLIMIT-78))|(1<<(SqlBase4GoParserLOGICAL-78))|(1<<(SqlBase4GoParserMAP-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBase4GoParserMINUTE-110))|(1<<(SqlBase4GoParserMONTH-110))|(1<<(SqlBase4GoParserNFC-110))|(1<<(SqlBase4GoParserNFD-110))|(1<<(SqlBase4GoParserNFKC-110))|(1<<(SqlBase4GoParserNFKD-110))|(1<<(SqlBase4GoParserNO-110))|(1<<(SqlBase4GoParserNONE-110))|(1<<(SqlBase4GoParserNULLIF-110))|(1<<(SqlBase4GoParserNULLS-110))|(1<<(SqlBase4GoParserONLY-110))|(1<<(SqlBase4GoParserOPTION-110))|(1<<(SqlBase4GoParserORDINALITY-110))|(1<<(SqlBase4GoParserOUTPUT-110))|(1<<(SqlBase4GoParserOVER-110))|(1<<(SqlBase4GoParserPARTITION-110))|(1<<(SqlBase4GoParserPARTITIONS-110))|(1<<(SqlBase4GoParserPOSITION-110))|(1<<(SqlBase4GoParserPRECEDING-110))|(1<<(SqlBase4GoParserPRIVILEGES-110))|(1<<(SqlBase4GoParserPROPERTIES-110))|(1<<(SqlBase4GoParserRANGE-110))|(1<<(SqlBase4GoParserREAD-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBase4GoParserRENAME-143))|(1<<(SqlBase4GoParserREPEATABLE-143))|(1<<(SqlBase4GoParserREPLACE-143))|(1<<(SqlBase4GoParserRESET-143))|(1<<(SqlBase4GoParserRESPECT-143))|(1<<(SqlBase4GoParserRESTRICT-143))|(1<<(SqlBase4GoParserRETURN-143))|(1<<(SqlBase4GoParserRETURNS-143))|(1<<(SqlBase4GoParserREVOKE-143))|(1<<(SqlBase4GoParserROLE-143))|(1<<(SqlBase4GoParserROLES-143))|(1<<(SqlBase4GoParserROLLBACK-143))|(1<<(SqlBase4GoParserROW-143))|(1<<(SqlBase4GoParserROWS-143))|(1<<(SqlBase4GoParserSCHEMA-143))|(1<<(SqlBase4GoParserSCHEMAS-143))|(1<<(SqlBase4GoParserSECOND-143))|(1<<(SqlBase4GoParserSERIALIZABLE-143))|(1<<(SqlBase4GoParserSESSION-143))|(1<<(SqlBase4GoParserSET-143))|(1<<(SqlBase4GoParserSETS-143))|(1<<(SqlBase4GoParserSHOW-143))|(1<<(SqlBase4GoParserSOME-143))|(1<<(SqlBase4GoParserSQL-143))|(1<<(SqlBase4GoParserSTART-143))|(1<<(SqlBase4GoParserSTATS-143))|(1<<(SqlBase4GoParserSUBSTRING-143))|(1<<(SqlBase4GoParserSYSTEM-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBase4GoParserTABLES-175))|(1<<(SqlBase4GoParserTABLESAMPLE-175))|(1<<(SqlBase4GoParserTEXT-175))|(1<<(SqlBase4GoParserTIME-175))|(1<<(SqlBase4GoParserTIMESTAMP-175))|(1<<(SqlBase4GoParserTO-175))|(1<<(SqlBase4GoParserTRANSACTION-175))|(1<<(SqlBase4GoParserTRY_CAST-175))|(1<<(SqlBase4GoParserTYPE-175))|(1<<(SqlBase4GoParserUNBOUNDED-175))|(1<<(SqlBase4GoParserUNCOMMITTED-175))|(1<<(SqlBase4GoParserUSE-175))|(1<<(SqlBase4GoParserUSER-175))|(1<<(SqlBase4GoParserVALIDATE-175))|(1<<(SqlBase4GoParserVERBOSE-175))|(1<<(SqlBase4GoParserVIEW-175))|(1<<(SqlBase4GoParserWORK-175))|(1<<(SqlBase4GoParserWRITE-175))|(1<<(SqlBase4GoParserYEAR-175))|(1<<(SqlBase4GoParserZONE-175)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SqlBase4GoParserIDENTIFIER-223))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-223))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-223))|(1<<(SqlBase4GoParserBACKQUOTED_IDENTIFIER-223)))) != 0) {
			{
				p.SetState(1435)
				p.QualifiedName()
			}
			p.SetState(1440)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1436)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1437)
					p.QualifiedName()
				}

				p.SetState(1442)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1445)
			p.Match(SqlBase4GoParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1456)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_primaryExpression)
				p.SetState(1448)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1449)
					p.Match(SqlBase4GoParserT__6)
				}
				{
					p.SetState(1450)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(1451)
					p.Match(SqlBase4GoParserT__7)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_primaryExpression)
				p.SetState(1453)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1454)
					p.Match(SqlBase4GoParserT__0)
				}
				{
					p.SetState(1455)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext())
	}

	return localctx
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_nullTreatment
	return p
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIGNORE, 0)
}

func (s *NullTreatmentContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULLS, 0)
}

func (s *NullTreatmentContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESPECT, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (p *SqlBase4GoParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SqlBase4GoParserRULE_nullTreatment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1465)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserIGNORE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1461)
			p.Match(SqlBase4GoParserIGNORE)
		}
		{
			p.SetState(1462)
			p.Match(SqlBase4GoParserNULLS)
		}

	case SqlBase4GoParserRESPECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1463)
			p.Match(SqlBase4GoParserRESPECT)
		}
		{
			p.SetState(1464)
			p.Match(SqlBase4GoParserNULLS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIME, 0)
}

func (s *TimeZoneIntervalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserZONE, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserZONE, 0)
}

func (s *TimeZoneStringContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *SqlBase4GoParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SqlBase4GoParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1473)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1467)
			p.Match(SqlBase4GoParserTIME)
		}
		{
			p.SetState(1468)
			p.Match(SqlBase4GoParserZONE)
		}
		{
			p.SetState(1469)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1470)
			p.Match(SqlBase4GoParserTIME)
		}
		{
			p.SetState(1471)
			p.Match(SqlBase4GoParserZONE)
		}
		{
			p.SetState(1472)
			p.Match(SqlBase4GoParserMyString)
		}

	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *SqlBase4GoParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlBase4GoParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-205)&-(0x1f+1)) == 0 && ((1<<uint((_la-205)))&((1<<(SqlBase4GoParserEQ-205))|(1<<(SqlBase4GoParserNEQ-205))|(1<<(SqlBase4GoParserLT-205))|(1<<(SqlBase4GoParserLTE-205))|(1<<(SqlBase4GoParserGT-205))|(1<<(SqlBase4GoParserGTE-205)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_comparisonQuantifier
	return p
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (p *SqlBase4GoParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlBase4GoParserRULE_comparisonQuantifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBase4GoParserALL || _la == SqlBase4GoParserANY || _la == SqlBase4GoParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *SqlBase4GoParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SqlBase4GoParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBase4GoParserFALSE || _la == SqlBase4GoParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTERVAL, 0)
}

func (s *IntervalContext) MyString() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMyString, 0)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *IntervalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPLUS, 0)
}

func (s *IntervalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMINUS, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *SqlBase4GoParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SqlBase4GoParserRULE_interval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1481)
		p.Match(SqlBase4GoParserINTERVAL)
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserPLUS || _la == SqlBase4GoParserMINUS {
		{
			p.SetState(1482)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserPLUS || _la == SqlBase4GoParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1485)
		p.Match(SqlBase4GoParserMyString)
	}
	{
		p.SetState(1486)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(1489)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1487)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(1488)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	}

	return localctx
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_intervalField
	return p
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserYEAR, 0)
}

func (s *IntervalFieldContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMONTH, 0)
}

func (s *IntervalFieldContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDAY, 0)
}

func (s *IntervalFieldContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserHOUR, 0)
}

func (s *IntervalFieldContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMINUTE, 0)
}

func (s *IntervalFieldContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSECOND, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (p *SqlBase4GoParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SqlBase4GoParserRULE_intervalField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1491)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBase4GoParserDAY || (((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(SqlBase4GoParserHOUR-83))|(1<<(SqlBase4GoParserMINUTE-83))|(1<<(SqlBase4GoParserMONTH-83)))) != 0) || _la == SqlBase4GoParserSECOND || _la == SqlBase4GoParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_normalForm
	return p
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFD, 0)
}

func (s *NormalFormContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFC, 0)
}

func (s *NormalFormContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFKD, 0)
}

func (s *NormalFormContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFKC, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (p *SqlBase4GoParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SqlBase4GoParserRULE_normalForm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1493)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-113)&-(0x1f+1)) == 0 && ((1<<uint((_la-113)))&((1<<(SqlBase4GoParserNFC-113))|(1<<(SqlBase4GoParserNFD-113))|(1<<(SqlBase4GoParserNFKC-113))|(1<<(SqlBase4GoParserNFKD-113)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) AllType_r() []IType_rContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_rContext)(nil)).Elem())
	var tst = make([]IType_rContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_rContext)
		}
	}

	return tst
}

func (s *TypesContext) Type_r(i int) IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SqlBase4GoParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SqlBase4GoParserRULE_types)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1495)
		p.Match(SqlBase4GoParserT__1)
	}
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(SqlBase4GoParserADD-11))|(1<<(SqlBase4GoParserADMIN-11))|(1<<(SqlBase4GoParserALL-11))|(1<<(SqlBase4GoParserANALYZE-11))|(1<<(SqlBase4GoParserANY-11))|(1<<(SqlBase4GoParserARRAY-11))|(1<<(SqlBase4GoParserASC-11))|(1<<(SqlBase4GoParserAT-11))|(1<<(SqlBase4GoParserBERNOULLI-11))|(1<<(SqlBase4GoParserCALL-11))|(1<<(SqlBase4GoParserCALLED-11))|(1<<(SqlBase4GoParserCASCADE-11))|(1<<(SqlBase4GoParserCATALOGS-11))|(1<<(SqlBase4GoParserCOLUMN-11))|(1<<(SqlBase4GoParserCOLUMNS-11))|(1<<(SqlBase4GoParserCOMMENT-11))|(1<<(SqlBase4GoParserCOMMIT-11))|(1<<(SqlBase4GoParserCOMMITTED-11))|(1<<(SqlBase4GoParserCURRENT-11))|(1<<(SqlBase4GoParserCURRENT_ROLE-11)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SqlBase4GoParserDATA-46))|(1<<(SqlBase4GoParserDATE-46))|(1<<(SqlBase4GoParserDAY-46))|(1<<(SqlBase4GoParserDESC-46))|(1<<(SqlBase4GoParserDETERMINISTIC-46))|(1<<(SqlBase4GoParserDISTRIBUTED-46))|(1<<(SqlBase4GoParserEXCLUDING-46))|(1<<(SqlBase4GoParserEXPLAIN-46))|(1<<(SqlBase4GoParserFILTER-46))|(1<<(SqlBase4GoParserFIRST-46))|(1<<(SqlBase4GoParserFOLLOWING-46))|(1<<(SqlBase4GoParserFORMAT-46))|(1<<(SqlBase4GoParserFUNCTION-46))|(1<<(SqlBase4GoParserFUNCTIONS-46))|(1<<(SqlBase4GoParserGRANT-46))|(1<<(SqlBase4GoParserGRANTED-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SqlBase4GoParserGRANTS-78))|(1<<(SqlBase4GoParserGRAPHVIZ-78))|(1<<(SqlBase4GoParserHOUR-78))|(1<<(SqlBase4GoParserIF-78))|(1<<(SqlBase4GoParserIGNORE-78))|(1<<(SqlBase4GoParserINCLUDING-78))|(1<<(SqlBase4GoParserINPUT-78))|(1<<(SqlBase4GoParserINTERVAL-78))|(1<<(SqlBase4GoParserIO-78))|(1<<(SqlBase4GoParserISOLATION-78))|(1<<(SqlBase4GoParserJSON-78))|(1<<(SqlBase4GoParserLANGUAGE-78))|(1<<(SqlBase4GoParserLAST-78))|(1<<(SqlBase4GoParserLATERAL-78))|(1<<(SqlBase4GoParserLEVEL-78))|(1<<(SqlBase4GoParserLIMIT-78))|(1<<(SqlBase4GoParserLOGICAL-78))|(1<<(SqlBase4GoParserMAP-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBase4GoParserMINUTE-110))|(1<<(SqlBase4GoParserMONTH-110))|(1<<(SqlBase4GoParserNFC-110))|(1<<(SqlBase4GoParserNFD-110))|(1<<(SqlBase4GoParserNFKC-110))|(1<<(SqlBase4GoParserNFKD-110))|(1<<(SqlBase4GoParserNO-110))|(1<<(SqlBase4GoParserNONE-110))|(1<<(SqlBase4GoParserNULLIF-110))|(1<<(SqlBase4GoParserNULLS-110))|(1<<(SqlBase4GoParserONLY-110))|(1<<(SqlBase4GoParserOPTION-110))|(1<<(SqlBase4GoParserORDINALITY-110))|(1<<(SqlBase4GoParserOUTPUT-110))|(1<<(SqlBase4GoParserOVER-110))|(1<<(SqlBase4GoParserPARTITION-110))|(1<<(SqlBase4GoParserPARTITIONS-110))|(1<<(SqlBase4GoParserPOSITION-110))|(1<<(SqlBase4GoParserPRECEDING-110))|(1<<(SqlBase4GoParserPRIVILEGES-110))|(1<<(SqlBase4GoParserPROPERTIES-110))|(1<<(SqlBase4GoParserRANGE-110))|(1<<(SqlBase4GoParserREAD-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBase4GoParserRENAME-143))|(1<<(SqlBase4GoParserREPEATABLE-143))|(1<<(SqlBase4GoParserREPLACE-143))|(1<<(SqlBase4GoParserRESET-143))|(1<<(SqlBase4GoParserRESPECT-143))|(1<<(SqlBase4GoParserRESTRICT-143))|(1<<(SqlBase4GoParserRETURN-143))|(1<<(SqlBase4GoParserRETURNS-143))|(1<<(SqlBase4GoParserREVOKE-143))|(1<<(SqlBase4GoParserROLE-143))|(1<<(SqlBase4GoParserROLES-143))|(1<<(SqlBase4GoParserROLLBACK-143))|(1<<(SqlBase4GoParserROW-143))|(1<<(SqlBase4GoParserROWS-143))|(1<<(SqlBase4GoParserSCHEMA-143))|(1<<(SqlBase4GoParserSCHEMAS-143))|(1<<(SqlBase4GoParserSECOND-143))|(1<<(SqlBase4GoParserSERIALIZABLE-143))|(1<<(SqlBase4GoParserSESSION-143))|(1<<(SqlBase4GoParserSET-143))|(1<<(SqlBase4GoParserSETS-143))|(1<<(SqlBase4GoParserSHOW-143))|(1<<(SqlBase4GoParserSOME-143))|(1<<(SqlBase4GoParserSQL-143))|(1<<(SqlBase4GoParserSTART-143))|(1<<(SqlBase4GoParserSTATS-143))|(1<<(SqlBase4GoParserSUBSTRING-143))|(1<<(SqlBase4GoParserSYSTEM-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBase4GoParserTABLES-175))|(1<<(SqlBase4GoParserTABLESAMPLE-175))|(1<<(SqlBase4GoParserTEXT-175))|(1<<(SqlBase4GoParserTIME-175))|(1<<(SqlBase4GoParserTIMESTAMP-175))|(1<<(SqlBase4GoParserTO-175))|(1<<(SqlBase4GoParserTRANSACTION-175))|(1<<(SqlBase4GoParserTRY_CAST-175))|(1<<(SqlBase4GoParserTYPE-175))|(1<<(SqlBase4GoParserUNBOUNDED-175))|(1<<(SqlBase4GoParserUNCOMMITTED-175))|(1<<(SqlBase4GoParserUSE-175))|(1<<(SqlBase4GoParserUSER-175))|(1<<(SqlBase4GoParserVALIDATE-175))|(1<<(SqlBase4GoParserVERBOSE-175))|(1<<(SqlBase4GoParserVIEW-175))|(1<<(SqlBase4GoParserWORK-175))|(1<<(SqlBase4GoParserWRITE-175))|(1<<(SqlBase4GoParserYEAR-175))|(1<<(SqlBase4GoParserZONE-175)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SqlBase4GoParserIDENTIFIER-223))|(1<<(SqlBase4GoParserDIGIT_IDENTIFIER-223))|(1<<(SqlBase4GoParserQUOTED_IDENTIFIER-223))|(1<<(SqlBase4GoParserBACKQUOTED_IDENTIFIER-223))|(1<<(SqlBase4GoParserTIME_WITH_TIME_ZONE-223))|(1<<(SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE-223))|(1<<(SqlBase4GoParserDOUBLE_PRECISION-223)))) != 0) {
		{
			p.SetState(1496)
			p.type_r(0)
		}
		p.SetState(1501)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1497)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1498)
				p.type_r(0)
			}

			p.SetState(1503)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1506)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// IType_rContext is an interface to support dynamic dispatch.
type IType_rContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// IsType_rContext differentiates from other interfaces.
	IsType_rContext()
}

type Type_rContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyType_rContext() *Type_rContext {
	var p = new(Type_rContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_type_r
	return p
}

func (*Type_rContext) IsType_rContext() {}

func NewType_rContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_rContext {
	var p = new(Type_rContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_type_r

	return p
}

func (s *Type_rContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_rContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *Type_rContext) GetTo() IIntervalFieldContext { return s.to }

func (s *Type_rContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *Type_rContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *Type_rContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserARRAY, 0)
}

func (s *Type_rContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLT, 0)
}

func (s *Type_rContext) AllType_r() []IType_rContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_rContext)(nil)).Elem())
	var tst = make([]IType_rContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_rContext)
		}
	}

	return tst
}

func (s *Type_rContext) Type_r(i int) IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *Type_rContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGT, 0)
}

func (s *Type_rContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMAP, 0)
}

func (s *Type_rContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROW, 0)
}

func (s *Type_rContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Type_rContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_rContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *Type_rContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *Type_rContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *Type_rContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTERVAL, 0)
}

func (s *Type_rContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *Type_rContext) AllIntervalField() []IIntervalFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem())
	var tst = make([]IIntervalFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntervalFieldContext)
		}
	}

	return tst
}

func (s *Type_rContext) IntervalField(i int) IIntervalFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *Type_rContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_rContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_rContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterType_r(s)
	}
}

func (s *Type_rContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitType_r(s)
	}
}

func (p *SqlBase4GoParser) Type_r() (localctx IType_rContext) {
	return p.type_r(0)
}

func (p *SqlBase4GoParser) type_r(_p int) (localctx IType_rContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType_rContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_rContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 108
	p.EnterRecursionRule(localctx, 108, SqlBase4GoParserRULE_type_r, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1509)
			p.Match(SqlBase4GoParserARRAY)
		}
		{
			p.SetState(1510)
			p.Match(SqlBase4GoParserLT)
		}
		{
			p.SetState(1511)
			p.type_r(0)
		}
		{
			p.SetState(1512)
			p.Match(SqlBase4GoParserGT)
		}

	case 2:
		{
			p.SetState(1514)
			p.Match(SqlBase4GoParserMAP)
		}
		{
			p.SetState(1515)
			p.Match(SqlBase4GoParserLT)
		}
		{
			p.SetState(1516)
			p.type_r(0)
		}
		{
			p.SetState(1517)
			p.Match(SqlBase4GoParserT__3)
		}
		{
			p.SetState(1518)
			p.type_r(0)
		}
		{
			p.SetState(1519)
			p.Match(SqlBase4GoParserGT)
		}

	case 3:
		{
			p.SetState(1521)
			p.Match(SqlBase4GoParserROW)
		}
		{
			p.SetState(1522)
			p.Match(SqlBase4GoParserT__1)
		}
		{
			p.SetState(1523)
			p.Identifier()
		}
		{
			p.SetState(1524)
			p.type_r(0)
		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1525)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1526)
				p.Identifier()
			}
			{
				p.SetState(1527)
				p.type_r(0)
			}

			p.SetState(1533)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1534)
			p.Match(SqlBase4GoParserT__2)
		}

	case 4:
		{
			p.SetState(1536)
			p.BaseType()
		}
		p.SetState(1548)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1537)
				p.Match(SqlBase4GoParserT__1)
			}
			{
				p.SetState(1538)
				p.TypeParameter()
			}
			p.SetState(1543)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBase4GoParserT__3 {
				{
					p.SetState(1539)
					p.Match(SqlBase4GoParserT__3)
				}
				{
					p.SetState(1540)
					p.TypeParameter()
				}

				p.SetState(1545)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1546)
				p.Match(SqlBase4GoParserT__2)
			}

		}

	case 5:
		{
			p.SetState(1550)
			p.Match(SqlBase4GoParserINTERVAL)
		}
		{
			p.SetState(1551)

			var _x = p.IntervalField()

			localctx.(*Type_rContext).from = _x
		}
		{
			p.SetState(1552)
			p.Match(SqlBase4GoParserTO)
		}
		{
			p.SetState(1553)

			var _x = p.IntervalField()

			localctx.(*Type_rContext).to = _x
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1561)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType_rContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SqlBase4GoParserRULE_type_r)
			p.SetState(1557)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
			}
			{
				p.SetState(1558)
				p.Match(SqlBase4GoParserARRAY)
			}

		}
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) Type_r() IType_rContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_rContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_rContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *SqlBase4GoParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SqlBase4GoParserRULE_typeParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1566)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1564)
			p.Match(SqlBase4GoParserINTEGER_VALUE)
		}

	case SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXPLAIN, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER, SqlBase4GoParserTIME_WITH_TIME_ZONE, SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE, SqlBase4GoParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1565)
			p.type_r(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) TIME_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIME_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDOUBLE_PRECISION, 0)
}

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *SqlBase4GoParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SqlBase4GoParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1572)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserTIME_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1568)
			p.Match(SqlBase4GoParserTIME_WITH_TIME_ZONE)
		}

	case SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1569)
			p.Match(SqlBase4GoParserTIMESTAMP_WITH_TIME_ZONE)
		}

	case SqlBase4GoParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1570)
			p.Match(SqlBase4GoParserDOUBLE_PRECISION)
		}

	case SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXPLAIN, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1571)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *SqlBase4GoParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SqlBase4GoParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1574)
		p.Match(SqlBase4GoParserWHEN)
	}
	{
		p.SetState(1575)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1576)
		p.Match(SqlBase4GoParserTHEN)
	}
	{
		p.SetState(1577)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_filter
	return p
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (p *SqlBase4GoParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SqlBase4GoParserRULE_filter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1579)
		p.Match(SqlBase4GoParserFILTER)
	}
	{
		p.SetState(1580)
		p.Match(SqlBase4GoParserT__1)
	}
	{
		p.SetState(1581)
		p.Match(SqlBase4GoParserWHERE)
	}
	{
		p.SetState(1582)
		p.booleanExpression(0)
	}
	{
		p.SetState(1583)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_over
	return p
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBase4GoParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortItemContext)(nil)).Elem())
	var tst = make([]ISortItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortItemContext)
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitOver(s)
	}
}

func (p *SqlBase4GoParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SqlBase4GoParserRULE_over)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		p.Match(SqlBase4GoParserOVER)
	}
	{
		p.SetState(1586)
		p.Match(SqlBase4GoParserT__1)
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserPARTITION {
		{
			p.SetState(1587)
			p.Match(SqlBase4GoParserPARTITION)
		}
		{
			p.SetState(1588)
			p.Match(SqlBase4GoParserBY)
		}
		{
			p.SetState(1589)

			var _x = p.Expression()

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1590)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1591)

				var _x = p.Expression()

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(1596)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserORDER {
		{
			p.SetState(1599)
			p.Match(SqlBase4GoParserORDER)
		}
		{
			p.SetState(1600)
			p.Match(SqlBase4GoParserBY)
		}
		{
			p.SetState(1601)
			p.SortItem()
		}
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBase4GoParserT__3 {
			{
				p.SetState(1602)
				p.Match(SqlBase4GoParserT__3)
			}
			{
				p.SetState(1603)
				p.SortItem()
			}

			p.SetState(1608)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBase4GoParserRANGE || _la == SqlBase4GoParserROWS {
		{
			p.SetState(1611)
			p.WindowFrame()
		}

	}
	{
		p.SetState(1614)
		p.Match(SqlBase4GoParserT__2)
	}

	return localctx
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart returns the start rule contexts.
	GetStart() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart sets the start rule contexts.
	SetStart(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start     IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_windowFrame
	return p
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart() IFrameBoundContext { return s.start }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart(v IFrameBoundContext) { s.start = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem())
	var tst = make([]IFrameBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFrameBoundContext)
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrameBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *SqlBase4GoParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SqlBase4GoParserRULE_windowFrame)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1616)

			var _m = p.Match(SqlBase4GoParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1617)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1618)

			var _m = p.Match(SqlBase4GoParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1619)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1620)

			var _m = p.Match(SqlBase4GoParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1621)
			p.Match(SqlBase4GoParserBETWEEN)
		}
		{
			p.SetState(1622)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}
		{
			p.SetState(1623)
			p.Match(SqlBase4GoParserAND)
		}
		{
			p.SetState(1624)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1626)

			var _m = p.Match(SqlBase4GoParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
		}
		{
			p.SetState(1627)
			p.Match(SqlBase4GoParserBETWEEN)
		}
		{
			p.SetState(1628)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start = _x
		}
		{
			p.SetState(1629)
			p.Match(SqlBase4GoParserAND)
		}
		{
			p.SetState(1630)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	}

	return localctx
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_frameBound
	return p
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyFrom(ctx *FrameBoundContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

type UnboundedFrameContext struct {
	*FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

type CurrentRowBoundContext struct {
	*FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	p.FrameBoundContext = NewEmptyFrameBoundContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (p *SqlBase4GoParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SqlBase4GoParserRULE_frameBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1634)
			p.Match(SqlBase4GoParserUNBOUNDED)
		}
		{
			p.SetState(1635)

			var _m = p.Match(SqlBase4GoParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1636)
			p.Match(SqlBase4GoParserUNBOUNDED)
		}
		{
			p.SetState(1637)

			var _m = p.Match(SqlBase4GoParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1638)
			p.Match(SqlBase4GoParserCURRENT)
		}
		{
			p.SetState(1639)
			p.Match(SqlBase4GoParserROW)
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1640)
			p.Expression()
		}
		{
			p.SetState(1641)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserFOLLOWING || _la == SqlBase4GoParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_explainOption
	return p
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) CopyFrom(ctx *ExplainOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainFormatContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainFormatContext {
	var p = new(ExplainFormatContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainFormatContext) GetValue() antlr.Token { return s.value }

func (s *ExplainFormatContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFORMAT, 0)
}

func (s *ExplainFormatContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTEXT, 0)
}

func (s *ExplainFormatContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRAPHVIZ, 0)
}

func (s *ExplainFormatContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserJSON, 0)
}

func (s *ExplainFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExplainFormat(s)
	}
}

func (s *ExplainFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExplainFormat(s)
	}
}

type ExplainTypeContext struct {
	*ExplainOptionContext
	value antlr.Token
}

func NewExplainTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainTypeContext {
	var p = new(ExplainTypeContext)

	p.ExplainOptionContext = NewEmptyExplainOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainTypeContext) GetValue() antlr.Token { return s.value }

func (s *ExplainTypeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTYPE, 0)
}

func (s *ExplainTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLOGICAL, 0)
}

func (s *ExplainTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDISTRIBUTED, 0)
}

func (s *ExplainTypeContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVALIDATE, 0)
}

func (s *ExplainTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIO, 0)
}

func (s *ExplainTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterExplainType(s)
	}
}

func (s *ExplainTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitExplainType(s)
	}
}

func (p *SqlBase4GoParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SqlBase4GoParserRULE_explainOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1649)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserFORMAT:
		localctx = NewExplainFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1645)
			p.Match(SqlBase4GoParserFORMAT)
		}
		{
			p.SetState(1646)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainFormatContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserGRAPHVIZ || _la == SqlBase4GoParserJSON || _la == SqlBase4GoParserTEXT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainFormatContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SqlBase4GoParserTYPE:
		localctx = NewExplainTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1647)
			p.Match(SqlBase4GoParserTYPE)
		}
		{
			p.SetState(1648)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainTypeContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserDISTRIBUTED || _la == SqlBase4GoParserIO || _la == SqlBase4GoParserLOGICAL || _la == SqlBase4GoParserVALIDATE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainTypeContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_transactionMode
	return p
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) CopyFrom(ctx *TransactionModeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TransactionAccessModeContext struct {
	*TransactionModeContext
	accessMode antlr.Token
}

func NewTransactionAccessModeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *TransactionAccessModeContext) GetAccessMode() antlr.Token { return s.accessMode }

func (s *TransactionAccessModeContext) SetAccessMode(v antlr.Token) { s.accessMode = v }

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWRITE, 0)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

type IsolationLevelContext struct {
	*TransactionModeContext
}

func NewIsolationLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	p.TransactionModeContext = NewEmptyTransactionModeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TransactionModeContext))

	return p
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLEVEL, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelOfIsolationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *SqlBase4GoParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SqlBase4GoParserRULE_transactionMode)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1656)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserISOLATION:
		localctx = NewIsolationLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1651)
			p.Match(SqlBase4GoParserISOLATION)
		}
		{
			p.SetState(1652)
			p.Match(SqlBase4GoParserLEVEL)
		}
		{
			p.SetState(1653)
			p.LevelOfIsolation()
		}

	case SqlBase4GoParserREAD:
		localctx = NewTransactionAccessModeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1654)
			p.Match(SqlBase4GoParserREAD)
		}
		{
			p.SetState(1655)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TransactionAccessModeContext).accessMode = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBase4GoParserONLY || _la == SqlBase4GoParserWRITE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TransactionAccessModeContext).accessMode = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_levelOfIsolation
	return p
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) CopyFrom(ctx *LevelOfIsolationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReadUncommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadUncommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadUncommittedContext {
	var p = new(ReadUncommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadUncommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUncommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREAD, 0)
}

func (s *ReadUncommittedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNCOMMITTED, 0)
}

func (s *ReadUncommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitReadUncommitted(s)
	}
}

type SerializableContext struct {
	*LevelOfIsolationContext
}

func NewSerializableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerializableContext {
	var p = new(SerializableContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *SerializableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializableContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSERIALIZABLE, 0)
}

func (s *SerializableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSerializable(s)
	}
}

func (s *SerializableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSerializable(s)
	}
}

type ReadCommittedContext struct {
	*LevelOfIsolationContext
}

func NewReadCommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadCommittedContext {
	var p = new(ReadCommittedContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadCommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadCommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREAD, 0)
}

func (s *ReadCommittedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMITTED, 0)
}

func (s *ReadCommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterReadCommitted(s)
	}
}

func (s *ReadCommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitReadCommitted(s)
	}
}

type RepeatableReadContext struct {
	*LevelOfIsolationContext
}

func NewRepeatableReadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatableReadContext {
	var p = new(RepeatableReadContext)

	p.LevelOfIsolationContext = NewEmptyLevelOfIsolationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *RepeatableReadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableReadContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREPEATABLE, 0)
}

func (s *RepeatableReadContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREAD, 0)
}

func (s *RepeatableReadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRepeatableRead(s)
	}
}

func (p *SqlBase4GoParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SqlBase4GoParserRULE_levelOfIsolation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1665)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReadUncommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1658)
			p.Match(SqlBase4GoParserREAD)
		}
		{
			p.SetState(1659)
			p.Match(SqlBase4GoParserUNCOMMITTED)
		}

	case 2:
		localctx = NewReadCommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1660)
			p.Match(SqlBase4GoParserREAD)
		}
		{
			p.SetState(1661)
			p.Match(SqlBase4GoParserCOMMITTED)
		}

	case 3:
		localctx = NewRepeatableReadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1662)
			p.Match(SqlBase4GoParserREPEATABLE)
		}
		{
			p.SetState(1663)
			p.Match(SqlBase4GoParserREAD)
		}

	case 4:
		localctx = NewSerializableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1664)
			p.Match(SqlBase4GoParserSERIALIZABLE)
		}

	}

	return localctx
}

// ICallArgumentContext is an interface to support dynamic dispatch.
type ICallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallArgumentContext differentiates from other interfaces.
	IsCallArgumentContext()
}

type CallArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentContext() *CallArgumentContext {
	var p = new(CallArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_callArgument
	return p
}

func (*CallArgumentContext) IsCallArgumentContext() {}

func NewCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentContext {
	var p = new(CallArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_callArgument

	return p
}

func (s *CallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentContext) CopyFrom(ctx *CallArgumentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionalArgumentContext struct {
	*CallArgumentContext
}

func NewPositionalArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionalArgumentContext {
	var p = new(PositionalArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *PositionalArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionalArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionalArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitPositionalArgument(s)
	}
}

type NamedArgumentContext struct {
	*CallArgumentContext
}

func NewNamedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	p.CallArgumentContext = NewEmptyCallArgumentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CallArgumentContext))

	return p
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (p *SqlBase4GoParser) CallArgument() (localctx ICallArgumentContext) {
	localctx = NewCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SqlBase4GoParserRULE_callArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1672)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPositionalArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1667)
			p.Expression()
		}

	case 2:
		localctx = NewNamedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1668)
			p.Identifier()
		}
		{
			p.SetState(1669)
			p.Match(SqlBase4GoParserT__8)
		}
		{
			p.SetState(1670)
			p.Expression()
		}

	}

	return localctx
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_privilege
	return p
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSELECT, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDELETE, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINSERT, 0)
}

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *SqlBase4GoParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SqlBase4GoParserRULE_privilege)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1678)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1674)
			p.Match(SqlBase4GoParserSELECT)
		}

	case SqlBase4GoParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1675)
			p.Match(SqlBase4GoParserDELETE)
		}

	case SqlBase4GoParserINSERT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1676)
			p.Match(SqlBase4GoParserINSERT)
		}

	case SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXPLAIN, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE, SqlBase4GoParserIDENTIFIER, SqlBase4GoParserDIGIT_IDENTIFIER, SqlBase4GoParserQUOTED_IDENTIFIER, SqlBase4GoParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1677)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *SqlBase4GoParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SqlBase4GoParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1680)
		p.Identifier()
	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1681)
				p.Match(SqlBase4GoParserT__0)
			}
			{
				p.SetState(1682)
				p.Identifier()
			}

		}
		p.SetState(1687)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext())
	}

	return localctx
}

// IGrantorContext is an interface to support dynamic dispatch.
type IGrantorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantorContext differentiates from other interfaces.
	IsGrantorContext()
}

type GrantorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantorContext() *GrantorContext {
	var p = new(GrantorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_grantor
	return p
}

func (*GrantorContext) IsGrantorContext() {}

func NewGrantorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantorContext {
	var p = new(GrantorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_grantor

	return p
}

func (s *GrantorContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantorContext) CopyFrom(ctx *GrantorContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *GrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CurrentUserGrantorContext struct {
	*GrantorContext
}

func NewCurrentUserGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserGrantorContext {
	var p = new(CurrentUserGrantorContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *CurrentUserGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserGrantorContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_USER, 0)
}

func (s *CurrentUserGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCurrentUserGrantor(s)
	}
}

type SpecifiedPrincipalContext struct {
	*GrantorContext
}

func NewSpecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecifiedPrincipalContext {
	var p = new(SpecifiedPrincipalContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *SpecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPrincipalContext) Principal() IPrincipalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrincipalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SpecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitSpecifiedPrincipal(s)
	}
}

type CurrentRoleGrantorContext struct {
	*GrantorContext
}

func NewCurrentRoleGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRoleGrantorContext {
	var p = new(CurrentRoleGrantorContext)

	p.GrantorContext = NewEmptyGrantorContext()
	p.parser = parser
	p.CopyFrom(ctx.(*GrantorContext))

	return p
}

func (s *CurrentRoleGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRoleGrantorContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_ROLE, 0)
}

func (s *CurrentRoleGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitCurrentRoleGrantor(s)
	}
}

func (p *SqlBase4GoParser) Grantor() (localctx IGrantorContext) {
	localctx = NewGrantorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SqlBase4GoParserRULE_grantor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentUserGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1688)
			p.Match(SqlBase4GoParserCURRENT_USER)
		}

	case 2:
		localctx = NewCurrentRoleGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1689)
			p.Match(SqlBase4GoParserCURRENT_ROLE)
		}

	case 3:
		localctx = NewSpecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1690)
			p.Principal()
		}

	}

	return localctx
}

// IPrincipalContext is an interface to support dynamic dispatch.
type IPrincipalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrincipalContext differentiates from other interfaces.
	IsPrincipalContext()
}

type PrincipalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalContext() *PrincipalContext {
	var p = new(PrincipalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_principal
	return p
}

func (*PrincipalContext) IsPrincipalContext() {}

func NewPrincipalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalContext {
	var p = new(PrincipalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_principal

	return p
}

func (s *PrincipalContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalContext) CopyFrom(ctx *PrincipalContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnspecifiedPrincipalContext struct {
	*PrincipalContext
}

func NewUnspecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnspecifiedPrincipalContext {
	var p = new(UnspecifiedPrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *UnspecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnspecifiedPrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnspecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUnspecifiedPrincipal(s)
	}
}

type UserPrincipalContext struct {
	*PrincipalContext
}

func NewUserPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserPrincipalContext {
	var p = new(UserPrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *UserPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPrincipalContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSER, 0)
}

func (s *UserPrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUserPrincipal(s)
	}
}

type RolePrincipalContext struct {
	*PrincipalContext
}

func NewRolePrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RolePrincipalContext {
	var p = new(RolePrincipalContext)

	p.PrincipalContext = NewEmptyPrincipalContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrincipalContext))

	return p
}

func (s *RolePrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolePrincipalContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *RolePrincipalContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolePrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRolePrincipal(s)
	}
}

func (p *SqlBase4GoParser) Principal() (localctx IPrincipalContext) {
	localctx = NewPrincipalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SqlBase4GoParserRULE_principal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1693)
			p.Match(SqlBase4GoParserUSER)
		}
		{
			p.SetState(1694)
			p.Identifier()
		}

	case 2:
		localctx = NewRolePrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1695)
			p.Match(SqlBase4GoParserROLE)
		}
		{
			p.SetState(1696)
			p.Identifier()
		}

	case 3:
		localctx = NewUnspecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1697)
			p.Identifier()
		}

	}

	return localctx
}

// IRolesContext is an interface to support dynamic dispatch.
type IRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRolesContext differentiates from other interfaces.
	IsRolesContext()
}

type RolesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRolesContext() *RolesContext {
	var p = new(RolesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_roles
	return p
}

func (*RolesContext) IsRolesContext() {}

func NewRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RolesContext {
	var p = new(RolesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_roles

	return p
}

func (s *RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *RolesContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *RolesContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterRoles(s)
	}
}

func (s *RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitRoles(s)
	}
}

func (p *SqlBase4GoParser) Roles() (localctx IRolesContext) {
	localctx = NewRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SqlBase4GoParserRULE_roles)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1700)
		p.Identifier()
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBase4GoParserT__3 {
		{
			p.SetState(1701)
			p.Match(SqlBase4GoParserT__3)
		}
		{
			p.SetState(1702)
			p.Identifier()
		}

		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *SqlBase4GoParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SqlBase4GoParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1713)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1708)
			p.Match(SqlBase4GoParserIDENTIFIER)
		}

	case SqlBase4GoParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1709)
			p.Match(SqlBase4GoParserQUOTED_IDENTIFIER)
		}

	case SqlBase4GoParserADD, SqlBase4GoParserADMIN, SqlBase4GoParserALL, SqlBase4GoParserANALYZE, SqlBase4GoParserANY, SqlBase4GoParserARRAY, SqlBase4GoParserASC, SqlBase4GoParserAT, SqlBase4GoParserBERNOULLI, SqlBase4GoParserCALL, SqlBase4GoParserCALLED, SqlBase4GoParserCASCADE, SqlBase4GoParserCATALOGS, SqlBase4GoParserCOLUMN, SqlBase4GoParserCOLUMNS, SqlBase4GoParserCOMMENT, SqlBase4GoParserCOMMIT, SqlBase4GoParserCOMMITTED, SqlBase4GoParserCURRENT, SqlBase4GoParserCURRENT_ROLE, SqlBase4GoParserDATA, SqlBase4GoParserDATE, SqlBase4GoParserDAY, SqlBase4GoParserDESC, SqlBase4GoParserDETERMINISTIC, SqlBase4GoParserDISTRIBUTED, SqlBase4GoParserEXCLUDING, SqlBase4GoParserEXPLAIN, SqlBase4GoParserFILTER, SqlBase4GoParserFIRST, SqlBase4GoParserFOLLOWING, SqlBase4GoParserFORMAT, SqlBase4GoParserFUNCTION, SqlBase4GoParserFUNCTIONS, SqlBase4GoParserGRANT, SqlBase4GoParserGRANTED, SqlBase4GoParserGRANTS, SqlBase4GoParserGRAPHVIZ, SqlBase4GoParserHOUR, SqlBase4GoParserIF, SqlBase4GoParserIGNORE, SqlBase4GoParserINCLUDING, SqlBase4GoParserINPUT, SqlBase4GoParserINTERVAL, SqlBase4GoParserIO, SqlBase4GoParserISOLATION, SqlBase4GoParserJSON, SqlBase4GoParserLANGUAGE, SqlBase4GoParserLAST, SqlBase4GoParserLATERAL, SqlBase4GoParserLEVEL, SqlBase4GoParserLIMIT, SqlBase4GoParserLOGICAL, SqlBase4GoParserMAP, SqlBase4GoParserMINUTE, SqlBase4GoParserMONTH, SqlBase4GoParserNFC, SqlBase4GoParserNFD, SqlBase4GoParserNFKC, SqlBase4GoParserNFKD, SqlBase4GoParserNO, SqlBase4GoParserNONE, SqlBase4GoParserNULLIF, SqlBase4GoParserNULLS, SqlBase4GoParserONLY, SqlBase4GoParserOPTION, SqlBase4GoParserORDINALITY, SqlBase4GoParserOUTPUT, SqlBase4GoParserOVER, SqlBase4GoParserPARTITION, SqlBase4GoParserPARTITIONS, SqlBase4GoParserPOSITION, SqlBase4GoParserPRECEDING, SqlBase4GoParserPRIVILEGES, SqlBase4GoParserPROPERTIES, SqlBase4GoParserRANGE, SqlBase4GoParserREAD, SqlBase4GoParserRENAME, SqlBase4GoParserREPEATABLE, SqlBase4GoParserREPLACE, SqlBase4GoParserRESET, SqlBase4GoParserRESPECT, SqlBase4GoParserRESTRICT, SqlBase4GoParserRETURN, SqlBase4GoParserRETURNS, SqlBase4GoParserREVOKE, SqlBase4GoParserROLE, SqlBase4GoParserROLES, SqlBase4GoParserROLLBACK, SqlBase4GoParserROW, SqlBase4GoParserROWS, SqlBase4GoParserSCHEMA, SqlBase4GoParserSCHEMAS, SqlBase4GoParserSECOND, SqlBase4GoParserSERIALIZABLE, SqlBase4GoParserSESSION, SqlBase4GoParserSET, SqlBase4GoParserSETS, SqlBase4GoParserSHOW, SqlBase4GoParserSOME, SqlBase4GoParserSQL, SqlBase4GoParserSTART, SqlBase4GoParserSTATS, SqlBase4GoParserSUBSTRING, SqlBase4GoParserSYSTEM, SqlBase4GoParserTABLES, SqlBase4GoParserTABLESAMPLE, SqlBase4GoParserTEXT, SqlBase4GoParserTIME, SqlBase4GoParserTIMESTAMP, SqlBase4GoParserTO, SqlBase4GoParserTRANSACTION, SqlBase4GoParserTRY_CAST, SqlBase4GoParserTYPE, SqlBase4GoParserUNBOUNDED, SqlBase4GoParserUNCOMMITTED, SqlBase4GoParserUSE, SqlBase4GoParserUSER, SqlBase4GoParserVALIDATE, SqlBase4GoParserVERBOSE, SqlBase4GoParserVIEW, SqlBase4GoParserWORK, SqlBase4GoParserWRITE, SqlBase4GoParserYEAR, SqlBase4GoParserZONE:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1710)
			p.NonReserved()
		}

	case SqlBase4GoParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1711)
			p.Match(SqlBase4GoParserBACKQUOTED_IDENTIFIER)
		}

	case SqlBase4GoParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1712)
			p.Match(SqlBase4GoParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type DoubleLiteralContext struct {
	*NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *SqlBase4GoParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SqlBase4GoParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SqlBase4GoParserDECIMAL_VALUE:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1715)
			p.Match(SqlBase4GoParserDECIMAL_VALUE)
		}

	case SqlBase4GoParserDOUBLE_VALUE:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1716)
			p.Match(SqlBase4GoParserDOUBLE_VALUE)
		}

	case SqlBase4GoParserINTEGER_VALUE:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1717)
			p.Match(SqlBase4GoParserINTEGER_VALUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SqlBase4GoParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBase4GoParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADD, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserADMIN, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserALL, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserANALYZE, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserANY, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserARRAY, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserAT, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserBERNOULLI, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCALL, 0)
}

func (s *NonReservedContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCALLED, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCASCADE, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCATALOGS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCOMMITTED, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT, 0)
}

func (s *NonReservedContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserCURRENT_ROLE, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDATE, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDAY, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDESC, 0)
}

func (s *NonReservedContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDETERMINISTIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXCLUDING, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserEXPLAIN, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFIRST, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFORMAT, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTION, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANT, 0)
}

func (s *NonReservedContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTED, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRANTS, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserHOUR, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIF, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIGNORE, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINCLUDING, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINPUT, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserINTERVAL, 0)
}

func (s *NonReservedContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserIO, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserISOLATION, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserJSON, 0)
}

func (s *NonReservedContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLANGUAGE, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLAST, 0)
}

func (s *NonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLATERAL, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLEVEL, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLIMIT, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserLOGICAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMAP, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMINUTE, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserMONTH, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFC, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFKC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNFKD, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNO, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNONE, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULLIF, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserNULLS, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOPTION, 0)
}

func (s *NonReservedContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserORDINALITY, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOUTPUT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPARTITIONS, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserPROPERTIES, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRANGE, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREAD, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRENAME, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESET, 0)
}

func (s *NonReservedContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESPECT, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRESTRICT, 0)
}

func (s *NonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRETURN, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserRETURNS, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserREVOKE, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLES, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROLLBACK, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSESSION, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSETS, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSQL, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSHOW, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSOME, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSTART, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSTATS, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserSYSTEM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTEXT, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTO, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserTYPE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserUSER, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVALIDATE, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVERBOSE, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserVIEW, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserWRITE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserYEAR, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBase4GoParserZONE, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBase4GoListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *SqlBase4GoParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SqlBase4GoParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(SqlBase4GoParserADD-11))|(1<<(SqlBase4GoParserADMIN-11))|(1<<(SqlBase4GoParserALL-11))|(1<<(SqlBase4GoParserANALYZE-11))|(1<<(SqlBase4GoParserANY-11))|(1<<(SqlBase4GoParserARRAY-11))|(1<<(SqlBase4GoParserASC-11))|(1<<(SqlBase4GoParserAT-11))|(1<<(SqlBase4GoParserBERNOULLI-11))|(1<<(SqlBase4GoParserCALL-11))|(1<<(SqlBase4GoParserCALLED-11))|(1<<(SqlBase4GoParserCASCADE-11))|(1<<(SqlBase4GoParserCATALOGS-11))|(1<<(SqlBase4GoParserCOLUMN-11))|(1<<(SqlBase4GoParserCOLUMNS-11))|(1<<(SqlBase4GoParserCOMMENT-11))|(1<<(SqlBase4GoParserCOMMIT-11))|(1<<(SqlBase4GoParserCOMMITTED-11))|(1<<(SqlBase4GoParserCURRENT-11))|(1<<(SqlBase4GoParserCURRENT_ROLE-11)))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SqlBase4GoParserDATA-46))|(1<<(SqlBase4GoParserDATE-46))|(1<<(SqlBase4GoParserDAY-46))|(1<<(SqlBase4GoParserDESC-46))|(1<<(SqlBase4GoParserDETERMINISTIC-46))|(1<<(SqlBase4GoParserDISTRIBUTED-46))|(1<<(SqlBase4GoParserEXCLUDING-46))|(1<<(SqlBase4GoParserEXPLAIN-46))|(1<<(SqlBase4GoParserFILTER-46))|(1<<(SqlBase4GoParserFIRST-46))|(1<<(SqlBase4GoParserFOLLOWING-46))|(1<<(SqlBase4GoParserFORMAT-46))|(1<<(SqlBase4GoParserFUNCTION-46))|(1<<(SqlBase4GoParserFUNCTIONS-46))|(1<<(SqlBase4GoParserGRANT-46))|(1<<(SqlBase4GoParserGRANTED-46)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SqlBase4GoParserGRANTS-78))|(1<<(SqlBase4GoParserGRAPHVIZ-78))|(1<<(SqlBase4GoParserHOUR-78))|(1<<(SqlBase4GoParserIF-78))|(1<<(SqlBase4GoParserIGNORE-78))|(1<<(SqlBase4GoParserINCLUDING-78))|(1<<(SqlBase4GoParserINPUT-78))|(1<<(SqlBase4GoParserINTERVAL-78))|(1<<(SqlBase4GoParserIO-78))|(1<<(SqlBase4GoParserISOLATION-78))|(1<<(SqlBase4GoParserJSON-78))|(1<<(SqlBase4GoParserLANGUAGE-78))|(1<<(SqlBase4GoParserLAST-78))|(1<<(SqlBase4GoParserLATERAL-78))|(1<<(SqlBase4GoParserLEVEL-78))|(1<<(SqlBase4GoParserLIMIT-78))|(1<<(SqlBase4GoParserLOGICAL-78))|(1<<(SqlBase4GoParserMAP-78)))) != 0) || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(SqlBase4GoParserMINUTE-110))|(1<<(SqlBase4GoParserMONTH-110))|(1<<(SqlBase4GoParserNFC-110))|(1<<(SqlBase4GoParserNFD-110))|(1<<(SqlBase4GoParserNFKC-110))|(1<<(SqlBase4GoParserNFKD-110))|(1<<(SqlBase4GoParserNO-110))|(1<<(SqlBase4GoParserNONE-110))|(1<<(SqlBase4GoParserNULLIF-110))|(1<<(SqlBase4GoParserNULLS-110))|(1<<(SqlBase4GoParserONLY-110))|(1<<(SqlBase4GoParserOPTION-110))|(1<<(SqlBase4GoParserORDINALITY-110))|(1<<(SqlBase4GoParserOUTPUT-110))|(1<<(SqlBase4GoParserOVER-110))|(1<<(SqlBase4GoParserPARTITION-110))|(1<<(SqlBase4GoParserPARTITIONS-110))|(1<<(SqlBase4GoParserPOSITION-110))|(1<<(SqlBase4GoParserPRECEDING-110))|(1<<(SqlBase4GoParserPRIVILEGES-110))|(1<<(SqlBase4GoParserPROPERTIES-110))|(1<<(SqlBase4GoParserRANGE-110))|(1<<(SqlBase4GoParserREAD-110)))) != 0) || (((_la-143)&-(0x1f+1)) == 0 && ((1<<uint((_la-143)))&((1<<(SqlBase4GoParserRENAME-143))|(1<<(SqlBase4GoParserREPEATABLE-143))|(1<<(SqlBase4GoParserREPLACE-143))|(1<<(SqlBase4GoParserRESET-143))|(1<<(SqlBase4GoParserRESPECT-143))|(1<<(SqlBase4GoParserRESTRICT-143))|(1<<(SqlBase4GoParserRETURN-143))|(1<<(SqlBase4GoParserRETURNS-143))|(1<<(SqlBase4GoParserREVOKE-143))|(1<<(SqlBase4GoParserROLE-143))|(1<<(SqlBase4GoParserROLES-143))|(1<<(SqlBase4GoParserROLLBACK-143))|(1<<(SqlBase4GoParserROW-143))|(1<<(SqlBase4GoParserROWS-143))|(1<<(SqlBase4GoParserSCHEMA-143))|(1<<(SqlBase4GoParserSCHEMAS-143))|(1<<(SqlBase4GoParserSECOND-143))|(1<<(SqlBase4GoParserSERIALIZABLE-143))|(1<<(SqlBase4GoParserSESSION-143))|(1<<(SqlBase4GoParserSET-143))|(1<<(SqlBase4GoParserSETS-143))|(1<<(SqlBase4GoParserSHOW-143))|(1<<(SqlBase4GoParserSOME-143))|(1<<(SqlBase4GoParserSQL-143))|(1<<(SqlBase4GoParserSTART-143))|(1<<(SqlBase4GoParserSTATS-143))|(1<<(SqlBase4GoParserSUBSTRING-143))|(1<<(SqlBase4GoParserSYSTEM-143)))) != 0) || (((_la-175)&-(0x1f+1)) == 0 && ((1<<uint((_la-175)))&((1<<(SqlBase4GoParserTABLES-175))|(1<<(SqlBase4GoParserTABLESAMPLE-175))|(1<<(SqlBase4GoParserTEXT-175))|(1<<(SqlBase4GoParserTIME-175))|(1<<(SqlBase4GoParserTIMESTAMP-175))|(1<<(SqlBase4GoParserTO-175))|(1<<(SqlBase4GoParserTRANSACTION-175))|(1<<(SqlBase4GoParserTRY_CAST-175))|(1<<(SqlBase4GoParserTYPE-175))|(1<<(SqlBase4GoParserUNBOUNDED-175))|(1<<(SqlBase4GoParserUNCOMMITTED-175))|(1<<(SqlBase4GoParserUSE-175))|(1<<(SqlBase4GoParserUSER-175))|(1<<(SqlBase4GoParserVALIDATE-175))|(1<<(SqlBase4GoParserVERBOSE-175))|(1<<(SqlBase4GoParserVIEW-175))|(1<<(SqlBase4GoParserWORK-175))|(1<<(SqlBase4GoParserWRITE-175))|(1<<(SqlBase4GoParserYEAR-175))|(1<<(SqlBase4GoParserZONE-175)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *SqlBase4GoParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 22:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 32:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 41:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 43:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 44:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 54:
		var t *Type_rContext = nil
		if localctx != nil {
			t = localctx.(*Type_rContext)
		}
		return p.Type_r_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBase4GoParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBase4GoParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBase4GoParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBase4GoParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBase4GoParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 12)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBase4GoParser) Type_r_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
